// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: offline_wire_formats.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Location_Nearby_Connections_OfflineFrame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: Location_Nearby_Connections_OfflineFrame.Version {
    get {return _version ?? .unknownVersion}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {self._version = nil}

  /// Right now there's only 1 version, but if there are more, exactly one of
  /// the following fields will be set.
  var v1: Location_Nearby_Connections_V1Frame {
    get {return _v1 ?? Location_Nearby_Connections_V1Frame()}
    set {_v1 = newValue}
  }
  /// Returns true if `v1` has been explicitly set.
  var hasV1: Bool {return self._v1 != nil}
  /// Clears the value of `v1`. Subsequent reads from it will return its default value.
  mutating func clearV1() {self._v1 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Version: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknownVersion // = 0
    case v1 // = 1

    init() {
      self = .unknownVersion
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownVersion
      case 1: self = .v1
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknownVersion: return 0
      case .v1: return 1
      }
    }

  }

  init() {}

  fileprivate var _version: Location_Nearby_Connections_OfflineFrame.Version? = nil
  fileprivate var _v1: Location_Nearby_Connections_V1Frame? = nil
}

#if swift(>=4.2)

extension Location_Nearby_Connections_OfflineFrame.Version: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Location_Nearby_Connections_V1Frame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Location_Nearby_Connections_V1Frame.FrameType {
    get {return _storage._type ?? .unknownFrameType}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {_uniqueStorage()._type = nil}

  /// Exactly one of the following fields will be set.
  var connectionRequest: Location_Nearby_Connections_ConnectionRequestFrame {
    get {return _storage._connectionRequest ?? Location_Nearby_Connections_ConnectionRequestFrame()}
    set {_uniqueStorage()._connectionRequest = newValue}
  }
  /// Returns true if `connectionRequest` has been explicitly set.
  var hasConnectionRequest: Bool {return _storage._connectionRequest != nil}
  /// Clears the value of `connectionRequest`. Subsequent reads from it will return its default value.
  mutating func clearConnectionRequest() {_uniqueStorage()._connectionRequest = nil}

  var connectionResponse: Location_Nearby_Connections_ConnectionResponseFrame {
    get {return _storage._connectionResponse ?? Location_Nearby_Connections_ConnectionResponseFrame()}
    set {_uniqueStorage()._connectionResponse = newValue}
  }
  /// Returns true if `connectionResponse` has been explicitly set.
  var hasConnectionResponse: Bool {return _storage._connectionResponse != nil}
  /// Clears the value of `connectionResponse`. Subsequent reads from it will return its default value.
  mutating func clearConnectionResponse() {_uniqueStorage()._connectionResponse = nil}

  var payloadTransfer: Location_Nearby_Connections_PayloadTransferFrame {
    get {return _storage._payloadTransfer ?? Location_Nearby_Connections_PayloadTransferFrame()}
    set {_uniqueStorage()._payloadTransfer = newValue}
  }
  /// Returns true if `payloadTransfer` has been explicitly set.
  var hasPayloadTransfer: Bool {return _storage._payloadTransfer != nil}
  /// Clears the value of `payloadTransfer`. Subsequent reads from it will return its default value.
  mutating func clearPayloadTransfer() {_uniqueStorage()._payloadTransfer = nil}

  var bandwidthUpgradeNegotiation: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame {
    get {return _storage._bandwidthUpgradeNegotiation ?? Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame()}
    set {_uniqueStorage()._bandwidthUpgradeNegotiation = newValue}
  }
  /// Returns true if `bandwidthUpgradeNegotiation` has been explicitly set.
  var hasBandwidthUpgradeNegotiation: Bool {return _storage._bandwidthUpgradeNegotiation != nil}
  /// Clears the value of `bandwidthUpgradeNegotiation`. Subsequent reads from it will return its default value.
  mutating func clearBandwidthUpgradeNegotiation() {_uniqueStorage()._bandwidthUpgradeNegotiation = nil}

  var keepAlive: Location_Nearby_Connections_KeepAliveFrame {
    get {return _storage._keepAlive ?? Location_Nearby_Connections_KeepAliveFrame()}
    set {_uniqueStorage()._keepAlive = newValue}
  }
  /// Returns true if `keepAlive` has been explicitly set.
  var hasKeepAlive: Bool {return _storage._keepAlive != nil}
  /// Clears the value of `keepAlive`. Subsequent reads from it will return its default value.
  mutating func clearKeepAlive() {_uniqueStorage()._keepAlive = nil}

  var disconnection: Location_Nearby_Connections_DisconnectionFrame {
    get {return _storage._disconnection ?? Location_Nearby_Connections_DisconnectionFrame()}
    set {_uniqueStorage()._disconnection = newValue}
  }
  /// Returns true if `disconnection` has been explicitly set.
  var hasDisconnection: Bool {return _storage._disconnection != nil}
  /// Clears the value of `disconnection`. Subsequent reads from it will return its default value.
  mutating func clearDisconnection() {_uniqueStorage()._disconnection = nil}

  var pairedKeyEncryption: Location_Nearby_Connections_PairedKeyEncryptionFrame {
    get {return _storage._pairedKeyEncryption ?? Location_Nearby_Connections_PairedKeyEncryptionFrame()}
    set {_uniqueStorage()._pairedKeyEncryption = newValue}
  }
  /// Returns true if `pairedKeyEncryption` has been explicitly set.
  var hasPairedKeyEncryption: Bool {return _storage._pairedKeyEncryption != nil}
  /// Clears the value of `pairedKeyEncryption`. Subsequent reads from it will return its default value.
  mutating func clearPairedKeyEncryption() {_uniqueStorage()._pairedKeyEncryption = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum FrameType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknownFrameType // = 0
    case connectionRequest // = 1
    case connectionResponse // = 2
    case payloadTransfer // = 3
    case bandwidthUpgradeNegotiation // = 4
    case keepAlive // = 5
    case disconnection // = 6
    case pairedKeyEncryption // = 7

    init() {
      self = .unknownFrameType
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownFrameType
      case 1: self = .connectionRequest
      case 2: self = .connectionResponse
      case 3: self = .payloadTransfer
      case 4: self = .bandwidthUpgradeNegotiation
      case 5: self = .keepAlive
      case 6: self = .disconnection
      case 7: self = .pairedKeyEncryption
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknownFrameType: return 0
      case .connectionRequest: return 1
      case .connectionResponse: return 2
      case .payloadTransfer: return 3
      case .bandwidthUpgradeNegotiation: return 4
      case .keepAlive: return 5
      case .disconnection: return 6
      case .pairedKeyEncryption: return 7
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Location_Nearby_Connections_V1Frame.FrameType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Location_Nearby_Connections_ConnectionRequestFrame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var endpointID: String {
    get {return _storage._endpointID ?? String()}
    set {_uniqueStorage()._endpointID = newValue}
  }
  /// Returns true if `endpointID` has been explicitly set.
  var hasEndpointID: Bool {return _storage._endpointID != nil}
  /// Clears the value of `endpointID`. Subsequent reads from it will return its default value.
  mutating func clearEndpointID() {_uniqueStorage()._endpointID = nil}

  var endpointName: String {
    get {return _storage._endpointName ?? String()}
    set {_uniqueStorage()._endpointName = newValue}
  }
  /// Returns true if `endpointName` has been explicitly set.
  var hasEndpointName: Bool {return _storage._endpointName != nil}
  /// Clears the value of `endpointName`. Subsequent reads from it will return its default value.
  mutating func clearEndpointName() {_uniqueStorage()._endpointName = nil}

  var handshakeData: Data {
    get {return _storage._handshakeData ?? Data()}
    set {_uniqueStorage()._handshakeData = newValue}
  }
  /// Returns true if `handshakeData` has been explicitly set.
  var hasHandshakeData: Bool {return _storage._handshakeData != nil}
  /// Clears the value of `handshakeData`. Subsequent reads from it will return its default value.
  mutating func clearHandshakeData() {_uniqueStorage()._handshakeData = nil}

  /// A random number generated for each outgoing connection that is presently
  /// used to act as a tiebreaker when 2 devices connect to each other
  /// simultaneously; this can also be used for other initialization-scoped
  /// things in the future.
  var nonce: Int32 {
    get {return _storage._nonce ?? 0}
    set {_uniqueStorage()._nonce = newValue}
  }
  /// Returns true if `nonce` has been explicitly set.
  var hasNonce: Bool {return _storage._nonce != nil}
  /// Clears the value of `nonce`. Subsequent reads from it will return its default value.
  mutating func clearNonce() {_uniqueStorage()._nonce = nil}

  /// The mediums this device supports upgrading to. This list should be filtered
  /// by both the strategy and this device's individual limitations.
  var mediums: [Location_Nearby_Connections_ConnectionRequestFrame.Medium] {
    get {return _storage._mediums}
    set {_uniqueStorage()._mediums = newValue}
  }

  var endpointInfo: Data {
    get {return _storage._endpointInfo ?? Data()}
    set {_uniqueStorage()._endpointInfo = newValue}
  }
  /// Returns true if `endpointInfo` has been explicitly set.
  var hasEndpointInfo: Bool {return _storage._endpointInfo != nil}
  /// Clears the value of `endpointInfo`. Subsequent reads from it will return its default value.
  mutating func clearEndpointInfo() {_uniqueStorage()._endpointInfo = nil}

  var mediumMetadata: Location_Nearby_Connections_MediumMetadata {
    get {return _storage._mediumMetadata ?? Location_Nearby_Connections_MediumMetadata()}
    set {_uniqueStorage()._mediumMetadata = newValue}
  }
  /// Returns true if `mediumMetadata` has been explicitly set.
  var hasMediumMetadata: Bool {return _storage._mediumMetadata != nil}
  /// Clears the value of `mediumMetadata`. Subsequent reads from it will return its default value.
  mutating func clearMediumMetadata() {_uniqueStorage()._mediumMetadata = nil}

  var keepAliveIntervalMillis: Int32 {
    get {return _storage._keepAliveIntervalMillis ?? 0}
    set {_uniqueStorage()._keepAliveIntervalMillis = newValue}
  }
  /// Returns true if `keepAliveIntervalMillis` has been explicitly set.
  var hasKeepAliveIntervalMillis: Bool {return _storage._keepAliveIntervalMillis != nil}
  /// Clears the value of `keepAliveIntervalMillis`. Subsequent reads from it will return its default value.
  mutating func clearKeepAliveIntervalMillis() {_uniqueStorage()._keepAliveIntervalMillis = nil}

  var keepAliveTimeoutMillis: Int32 {
    get {return _storage._keepAliveTimeoutMillis ?? 0}
    set {_uniqueStorage()._keepAliveTimeoutMillis = newValue}
  }
  /// Returns true if `keepAliveTimeoutMillis` has been explicitly set.
  var hasKeepAliveTimeoutMillis: Bool {return _storage._keepAliveTimeoutMillis != nil}
  /// Clears the value of `keepAliveTimeoutMillis`. Subsequent reads from it will return its default value.
  mutating func clearKeepAliveTimeoutMillis() {_uniqueStorage()._keepAliveTimeoutMillis = nil}

  /// The type of {@link Device} object.
  var deviceType: Int32 {
    get {return _storage._deviceType ?? 0}
    set {_uniqueStorage()._deviceType = newValue}
  }
  /// Returns true if `deviceType` has been explicitly set.
  var hasDeviceType: Bool {return _storage._deviceType != nil}
  /// Clears the value of `deviceType`. Subsequent reads from it will return its default value.
  mutating func clearDeviceType() {_uniqueStorage()._deviceType = nil}

  /// The bytes of serialized {@link Device} object.
  var deviceInfo: Data {
    get {return _storage._deviceInfo ?? Data()}
    set {_uniqueStorage()._deviceInfo = newValue}
  }
  /// Returns true if `deviceInfo` has been explicitly set.
  var hasDeviceInfo: Bool {return _storage._deviceInfo != nil}
  /// Clears the value of `deviceInfo`. Subsequent reads from it will return its default value.
  mutating func clearDeviceInfo() {_uniqueStorage()._deviceInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Should always match cs/symbol:location.nearby.proto.connections.Medium
  /// LINT.IfChange
  enum Medium: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknownMedium // = 0
    case mdns // = 1
    case bluetooth // = 2
    case wifiHotspot // = 3
    case ble // = 4
    case wifiLan // = 5
    case wifiAware // = 6
    case nfc // = 7
    case wifiDirect // = 8
    case webRtc // = 9
    case bleL2Cap // = 10
    case usb // = 11

    init() {
      self = .unknownMedium
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownMedium
      case 1: self = .mdns
      case 2: self = .bluetooth
      case 3: self = .wifiHotspot
      case 4: self = .ble
      case 5: self = .wifiLan
      case 6: self = .wifiAware
      case 7: self = .nfc
      case 8: self = .wifiDirect
      case 9: self = .webRtc
      case 10: self = .bleL2Cap
      case 11: self = .usb
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknownMedium: return 0
      case .mdns: return 1
      case .bluetooth: return 2
      case .wifiHotspot: return 3
      case .ble: return 4
      case .wifiLan: return 5
      case .wifiAware: return 6
      case .nfc: return 7
      case .wifiDirect: return 8
      case .webRtc: return 9
      case .bleL2Cap: return 10
      case .usb: return 11
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Location_Nearby_Connections_ConnectionRequestFrame.Medium: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// This doesn't need to send back endpoint_id and endpoint_name (like
/// the ConnectionRequestFrame does) because those have already been
/// transmitted out-of-band, at the time this endpoint was discovered.
struct Location_Nearby_Connections_ConnectionResponseFrame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// One of:
  ///
  /// - ConnectionsStatusCodes.STATUS_OK
  /// - ConnectionsStatusCodes.STATUS_CONNECTION_REJECTED.
  var status: Int32 {
    get {return _status ?? 0}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var handshakeData: Data {
    get {return _handshakeData ?? Data()}
    set {_handshakeData = newValue}
  }
  /// Returns true if `handshakeData` has been explicitly set.
  var hasHandshakeData: Bool {return self._handshakeData != nil}
  /// Clears the value of `handshakeData`. Subsequent reads from it will return its default value.
  mutating func clearHandshakeData() {self._handshakeData = nil}

  var response: Location_Nearby_Connections_ConnectionResponseFrame.ResponseStatus {
    get {return _response ?? .unknownResponseStatus}
    set {_response = newValue}
  }
  /// Returns true if `response` has been explicitly set.
  var hasResponse: Bool {return self._response != nil}
  /// Clears the value of `response`. Subsequent reads from it will return its default value.
  mutating func clearResponse() {self._response = nil}

  var osInfo: Location_Nearby_Connections_OsInfo {
    get {return _osInfo ?? Location_Nearby_Connections_OsInfo()}
    set {_osInfo = newValue}
  }
  /// Returns true if `osInfo` has been explicitly set.
  var hasOsInfo: Bool {return self._osInfo != nil}
  /// Clears the value of `osInfo`. Subsequent reads from it will return its default value.
  mutating func clearOsInfo() {self._osInfo = nil}

  /// A bitmask value to indicate which medium supports Multiplex transmission
  /// feature. Each supporting medium could utilize one bit starting from the
  /// least significant bit in this field. eq. BT utilizes the LSB bit which 0x01
  /// means bt supports multiplex while 0x00 means not. Refer to ClientProxy.java
  /// for the bit usages.
  var multiplexSocketBitmask: Int32 {
    get {return _multiplexSocketBitmask ?? 0}
    set {_multiplexSocketBitmask = newValue}
  }
  /// Returns true if `multiplexSocketBitmask` has been explicitly set.
  var hasMultiplexSocketBitmask: Bool {return self._multiplexSocketBitmask != nil}
  /// Clears the value of `multiplexSocketBitmask`. Subsequent reads from it will return its default value.
  mutating func clearMultiplexSocketBitmask() {self._multiplexSocketBitmask = nil}

  var nearbyConnectionsVersion: Int32 {
    get {return _nearbyConnectionsVersion ?? 0}
    set {_nearbyConnectionsVersion = newValue}
  }
  /// Returns true if `nearbyConnectionsVersion` has been explicitly set.
  var hasNearbyConnectionsVersion: Bool {return self._nearbyConnectionsVersion != nil}
  /// Clears the value of `nearbyConnectionsVersion`. Subsequent reads from it will return its default value.
  mutating func clearNearbyConnectionsVersion() {self._nearbyConnectionsVersion = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Used to replace the status integer parameter with a meaningful enum item.
  /// Map ConnectionsStatusCodes.STATUS_OK to ACCEPT and
  /// ConnectionsStatusCodes.STATUS_CONNECTION_REJECTED to REJECT.
  /// Flag: connection_replace_status_with_response_connectionResponseFrame
  enum ResponseStatus: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknownResponseStatus // = 0
    case accept // = 1
    case reject // = 2

    init() {
      self = .unknownResponseStatus
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownResponseStatus
      case 1: self = .accept
      case 2: self = .reject
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknownResponseStatus: return 0
      case .accept: return 1
      case .reject: return 2
      }
    }

  }

  init() {}

  fileprivate var _status: Int32? = nil
  fileprivate var _handshakeData: Data? = nil
  fileprivate var _response: Location_Nearby_Connections_ConnectionResponseFrame.ResponseStatus? = nil
  fileprivate var _osInfo: Location_Nearby_Connections_OsInfo? = nil
  fileprivate var _multiplexSocketBitmask: Int32? = nil
  fileprivate var _nearbyConnectionsVersion: Int32? = nil
}

#if swift(>=4.2)

extension Location_Nearby_Connections_ConnectionResponseFrame.ResponseStatus: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Location_Nearby_Connections_PayloadTransferFrame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var packetType: Location_Nearby_Connections_PayloadTransferFrame.PacketType {
    get {return _packetType ?? .unknownPacketType}
    set {_packetType = newValue}
  }
  /// Returns true if `packetType` has been explicitly set.
  var hasPacketType: Bool {return self._packetType != nil}
  /// Clears the value of `packetType`. Subsequent reads from it will return its default value.
  mutating func clearPacketType() {self._packetType = nil}

  var payloadHeader: Location_Nearby_Connections_PayloadTransferFrame.PayloadHeader {
    get {return _payloadHeader ?? Location_Nearby_Connections_PayloadTransferFrame.PayloadHeader()}
    set {_payloadHeader = newValue}
  }
  /// Returns true if `payloadHeader` has been explicitly set.
  var hasPayloadHeader: Bool {return self._payloadHeader != nil}
  /// Clears the value of `payloadHeader`. Subsequent reads from it will return its default value.
  mutating func clearPayloadHeader() {self._payloadHeader = nil}

  /// Exactly one of the following fields will be set, depending on the type.
  var payloadChunk: Location_Nearby_Connections_PayloadTransferFrame.PayloadChunk {
    get {return _payloadChunk ?? Location_Nearby_Connections_PayloadTransferFrame.PayloadChunk()}
    set {_payloadChunk = newValue}
  }
  /// Returns true if `payloadChunk` has been explicitly set.
  var hasPayloadChunk: Bool {return self._payloadChunk != nil}
  /// Clears the value of `payloadChunk`. Subsequent reads from it will return its default value.
  mutating func clearPayloadChunk() {self._payloadChunk = nil}

  var controlMessage: Location_Nearby_Connections_PayloadTransferFrame.ControlMessage {
    get {return _controlMessage ?? Location_Nearby_Connections_PayloadTransferFrame.ControlMessage()}
    set {_controlMessage = newValue}
  }
  /// Returns true if `controlMessage` has been explicitly set.
  var hasControlMessage: Bool {return self._controlMessage != nil}
  /// Clears the value of `controlMessage`. Subsequent reads from it will return its default value.
  mutating func clearControlMessage() {self._controlMessage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum PacketType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknownPacketType // = 0
    case data // = 1
    case control // = 2

    init() {
      self = .unknownPacketType
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownPacketType
      case 1: self = .data
      case 2: self = .control
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknownPacketType: return 0
      case .data: return 1
      case .control: return 2
      }
    }

  }

  struct PayloadHeader {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: Int64 {
      get {return _id ?? 0}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating func clearID() {self._id = nil}

    var type: Location_Nearby_Connections_PayloadTransferFrame.PayloadHeader.PayloadType {
      get {return _type ?? .unknownPayloadType}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() {self._type = nil}

    var totalSize: Int64 {
      get {return _totalSize ?? 0}
      set {_totalSize = newValue}
    }
    /// Returns true if `totalSize` has been explicitly set.
    var hasTotalSize: Bool {return self._totalSize != nil}
    /// Clears the value of `totalSize`. Subsequent reads from it will return its default value.
    mutating func clearTotalSize() {self._totalSize = nil}

    var isSensitive: Bool {
      get {return _isSensitive ?? false}
      set {_isSensitive = newValue}
    }
    /// Returns true if `isSensitive` has been explicitly set.
    var hasIsSensitive: Bool {return self._isSensitive != nil}
    /// Clears the value of `isSensitive`. Subsequent reads from it will return its default value.
    mutating func clearIsSensitive() {self._isSensitive = nil}

    var fileName: String {
      get {return _fileName ?? String()}
      set {_fileName = newValue}
    }
    /// Returns true if `fileName` has been explicitly set.
    var hasFileName: Bool {return self._fileName != nil}
    /// Clears the value of `fileName`. Subsequent reads from it will return its default value.
    mutating func clearFileName() {self._fileName = nil}

    var parentFolder: String {
      get {return _parentFolder ?? String()}
      set {_parentFolder = newValue}
    }
    /// Returns true if `parentFolder` has been explicitly set.
    var hasParentFolder: Bool {return self._parentFolder != nil}
    /// Clears the value of `parentFolder`. Subsequent reads from it will return its default value.
    mutating func clearParentFolder() {self._parentFolder = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum PayloadType: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case unknownPayloadType // = 0
      case bytes // = 1
      case file // = 2
      case stream // = 3

      init() {
        self = .unknownPayloadType
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknownPayloadType
        case 1: self = .bytes
        case 2: self = .file
        case 3: self = .stream
        default: return nil
        }
      }

      var rawValue: Int {
        switch self {
        case .unknownPayloadType: return 0
        case .bytes: return 1
        case .file: return 2
        case .stream: return 3
        }
      }

    }

    init() {}

    fileprivate var _id: Int64? = nil
    fileprivate var _type: Location_Nearby_Connections_PayloadTransferFrame.PayloadHeader.PayloadType? = nil
    fileprivate var _totalSize: Int64? = nil
    fileprivate var _isSensitive: Bool? = nil
    fileprivate var _fileName: String? = nil
    fileprivate var _parentFolder: String? = nil
  }

  /// Accompanies DATA packets.
  struct PayloadChunk {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var flags: Int32 {
      get {return _flags ?? 0}
      set {_flags = newValue}
    }
    /// Returns true if `flags` has been explicitly set.
    var hasFlags: Bool {return self._flags != nil}
    /// Clears the value of `flags`. Subsequent reads from it will return its default value.
    mutating func clearFlags() {self._flags = nil}

    var offset: Int64 {
      get {return _offset ?? 0}
      set {_offset = newValue}
    }
    /// Returns true if `offset` has been explicitly set.
    var hasOffset: Bool {return self._offset != nil}
    /// Clears the value of `offset`. Subsequent reads from it will return its default value.
    mutating func clearOffset() {self._offset = nil}

    var body: Data {
      get {return _body ?? Data()}
      set {_body = newValue}
    }
    /// Returns true if `body` has been explicitly set.
    var hasBody: Bool {return self._body != nil}
    /// Clears the value of `body`. Subsequent reads from it will return its default value.
    mutating func clearBody() {self._body = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Flags: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case lastChunk // = 1

      init() {
        self = .lastChunk
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 1: self = .lastChunk
        default: return nil
        }
      }

      var rawValue: Int {
        switch self {
        case .lastChunk: return 1
        }
      }

    }

    init() {}

    fileprivate var _flags: Int32? = nil
    fileprivate var _offset: Int64? = nil
    fileprivate var _body: Data? = nil
  }

  /// Accompanies CONTROL packets.
  struct ControlMessage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var event: Location_Nearby_Connections_PayloadTransferFrame.ControlMessage.EventType {
      get {return _event ?? .unknownEventType}
      set {_event = newValue}
    }
    /// Returns true if `event` has been explicitly set.
    var hasEvent: Bool {return self._event != nil}
    /// Clears the value of `event`. Subsequent reads from it will return its default value.
    mutating func clearEvent() {self._event = nil}

    var offset: Int64 {
      get {return _offset ?? 0}
      set {_offset = newValue}
    }
    /// Returns true if `offset` has been explicitly set.
    var hasOffset: Bool {return self._offset != nil}
    /// Clears the value of `offset`. Subsequent reads from it will return its default value.
    mutating func clearOffset() {self._offset = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum EventType: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case unknownEventType // = 0
      case payloadError // = 1
      case payloadCanceled // = 2
      case payloadReceivedAck // = 3

      init() {
        self = .unknownEventType
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknownEventType
        case 1: self = .payloadError
        case 2: self = .payloadCanceled
        case 3: self = .payloadReceivedAck
        default: return nil
        }
      }

      var rawValue: Int {
        switch self {
        case .unknownEventType: return 0
        case .payloadError: return 1
        case .payloadCanceled: return 2
        case .payloadReceivedAck: return 3
        }
      }

    }

    init() {}

    fileprivate var _event: Location_Nearby_Connections_PayloadTransferFrame.ControlMessage.EventType? = nil
    fileprivate var _offset: Int64? = nil
  }

  init() {}

  fileprivate var _packetType: Location_Nearby_Connections_PayloadTransferFrame.PacketType? = nil
  fileprivate var _payloadHeader: Location_Nearby_Connections_PayloadTransferFrame.PayloadHeader? = nil
  fileprivate var _payloadChunk: Location_Nearby_Connections_PayloadTransferFrame.PayloadChunk? = nil
  fileprivate var _controlMessage: Location_Nearby_Connections_PayloadTransferFrame.ControlMessage? = nil
}

#if swift(>=4.2)

extension Location_Nearby_Connections_PayloadTransferFrame.PacketType: CaseIterable {
  // Support synthesized by the compiler.
}

extension Location_Nearby_Connections_PayloadTransferFrame.PayloadHeader.PayloadType: CaseIterable {
  // Support synthesized by the compiler.
}

extension Location_Nearby_Connections_PayloadTransferFrame.PayloadChunk.Flags: CaseIterable {
  // Support synthesized by the compiler.
}

extension Location_Nearby_Connections_PayloadTransferFrame.ControlMessage.EventType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eventType: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.EventType {
    get {return _eventType ?? .unknownEventType}
    set {_eventType = newValue}
  }
  /// Returns true if `eventType` has been explicitly set.
  var hasEventType: Bool {return self._eventType != nil}
  /// Clears the value of `eventType`. Subsequent reads from it will return its default value.
  mutating func clearEventType() {self._eventType = nil}

  /// Exactly one of the following fields will be set.
  var upgradePathInfo: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo {
    get {return _upgradePathInfo ?? Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo()}
    set {_upgradePathInfo = newValue}
  }
  /// Returns true if `upgradePathInfo` has been explicitly set.
  var hasUpgradePathInfo: Bool {return self._upgradePathInfo != nil}
  /// Clears the value of `upgradePathInfo`. Subsequent reads from it will return its default value.
  mutating func clearUpgradePathInfo() {self._upgradePathInfo = nil}

  var clientIntroduction: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.ClientIntroduction {
    get {return _clientIntroduction ?? Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.ClientIntroduction()}
    set {_clientIntroduction = newValue}
  }
  /// Returns true if `clientIntroduction` has been explicitly set.
  var hasClientIntroduction: Bool {return self._clientIntroduction != nil}
  /// Clears the value of `clientIntroduction`. Subsequent reads from it will return its default value.
  mutating func clearClientIntroduction() {self._clientIntroduction = nil}

  var clientIntroductionAck: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.ClientIntroductionAck {
    get {return _clientIntroductionAck ?? Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.ClientIntroductionAck()}
    set {_clientIntroductionAck = newValue}
  }
  /// Returns true if `clientIntroductionAck` has been explicitly set.
  var hasClientIntroductionAck: Bool {return self._clientIntroductionAck != nil}
  /// Clears the value of `clientIntroductionAck`. Subsequent reads from it will return its default value.
  mutating func clearClientIntroductionAck() {self._clientIntroductionAck = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum EventType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknownEventType // = 0
    case upgradePathAvailable // = 1
    case lastWriteToPriorChannel // = 2
    case safeToClosePriorChannel // = 3
    case clientIntroduction // = 4
    case upgradeFailure // = 5
    case clientIntroductionAck // = 6

    init() {
      self = .unknownEventType
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownEventType
      case 1: self = .upgradePathAvailable
      case 2: self = .lastWriteToPriorChannel
      case 3: self = .safeToClosePriorChannel
      case 4: self = .clientIntroduction
      case 5: self = .upgradeFailure
      case 6: self = .clientIntroductionAck
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknownEventType: return 0
      case .upgradePathAvailable: return 1
      case .lastWriteToPriorChannel: return 2
      case .safeToClosePriorChannel: return 3
      case .clientIntroduction: return 4
      case .upgradeFailure: return 5
      case .clientIntroductionAck: return 6
      }
    }

  }

  /// Accompanies UPGRADE_PATH_AVAILABLE and UPGRADE_FAILURE events.
  struct UpgradePathInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var medium: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.Medium {
      get {return _storage._medium ?? .unknownMedium}
      set {_uniqueStorage()._medium = newValue}
    }
    /// Returns true if `medium` has been explicitly set.
    var hasMedium: Bool {return _storage._medium != nil}
    /// Clears the value of `medium`. Subsequent reads from it will return its default value.
    mutating func clearMedium() {_uniqueStorage()._medium = nil}

    /// Exactly one of the following fields will be set.
    var wifiHotspotCredentials: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials {
      get {return _storage._wifiHotspotCredentials ?? Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials()}
      set {_uniqueStorage()._wifiHotspotCredentials = newValue}
    }
    /// Returns true if `wifiHotspotCredentials` has been explicitly set.
    var hasWifiHotspotCredentials: Bool {return _storage._wifiHotspotCredentials != nil}
    /// Clears the value of `wifiHotspotCredentials`. Subsequent reads from it will return its default value.
    mutating func clearWifiHotspotCredentials() {_uniqueStorage()._wifiHotspotCredentials = nil}

    var wifiLanSocket: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket {
      get {return _storage._wifiLanSocket ?? Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket()}
      set {_uniqueStorage()._wifiLanSocket = newValue}
    }
    /// Returns true if `wifiLanSocket` has been explicitly set.
    var hasWifiLanSocket: Bool {return _storage._wifiLanSocket != nil}
    /// Clears the value of `wifiLanSocket`. Subsequent reads from it will return its default value.
    mutating func clearWifiLanSocket() {_uniqueStorage()._wifiLanSocket = nil}

    var bluetoothCredentials: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials {
      get {return _storage._bluetoothCredentials ?? Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials()}
      set {_uniqueStorage()._bluetoothCredentials = newValue}
    }
    /// Returns true if `bluetoothCredentials` has been explicitly set.
    var hasBluetoothCredentials: Bool {return _storage._bluetoothCredentials != nil}
    /// Clears the value of `bluetoothCredentials`. Subsequent reads from it will return its default value.
    mutating func clearBluetoothCredentials() {_uniqueStorage()._bluetoothCredentials = nil}

    var wifiAwareCredentials: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials {
      get {return _storage._wifiAwareCredentials ?? Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials()}
      set {_uniqueStorage()._wifiAwareCredentials = newValue}
    }
    /// Returns true if `wifiAwareCredentials` has been explicitly set.
    var hasWifiAwareCredentials: Bool {return _storage._wifiAwareCredentials != nil}
    /// Clears the value of `wifiAwareCredentials`. Subsequent reads from it will return its default value.
    mutating func clearWifiAwareCredentials() {_uniqueStorage()._wifiAwareCredentials = nil}

    var wifiDirectCredentials: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials {
      get {return _storage._wifiDirectCredentials ?? Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials()}
      set {_uniqueStorage()._wifiDirectCredentials = newValue}
    }
    /// Returns true if `wifiDirectCredentials` has been explicitly set.
    var hasWifiDirectCredentials: Bool {return _storage._wifiDirectCredentials != nil}
    /// Clears the value of `wifiDirectCredentials`. Subsequent reads from it will return its default value.
    mutating func clearWifiDirectCredentials() {_uniqueStorage()._wifiDirectCredentials = nil}

    var webRtcCredentials: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials {
      get {return _storage._webRtcCredentials ?? Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials()}
      set {_uniqueStorage()._webRtcCredentials = newValue}
    }
    /// Returns true if `webRtcCredentials` has been explicitly set.
    var hasWebRtcCredentials: Bool {return _storage._webRtcCredentials != nil}
    /// Clears the value of `webRtcCredentials`. Subsequent reads from it will return its default value.
    mutating func clearWebRtcCredentials() {_uniqueStorage()._webRtcCredentials = nil}

    /// Disable Encryption for this upgrade medium to improve throughput.
    var supportsDisablingEncryption: Bool {
      get {return _storage._supportsDisablingEncryption ?? false}
      set {_uniqueStorage()._supportsDisablingEncryption = newValue}
    }
    /// Returns true if `supportsDisablingEncryption` has been explicitly set.
    var hasSupportsDisablingEncryption: Bool {return _storage._supportsDisablingEncryption != nil}
    /// Clears the value of `supportsDisablingEncryption`. Subsequent reads from it will return its default value.
    mutating func clearSupportsDisablingEncryption() {_uniqueStorage()._supportsDisablingEncryption = nil}

    /// An ack will be sent after the CLIENT_INTRODUCTION frame.
    var supportsClientIntroductionAck: Bool {
      get {return _storage._supportsClientIntroductionAck ?? false}
      set {_uniqueStorage()._supportsClientIntroductionAck = newValue}
    }
    /// Returns true if `supportsClientIntroductionAck` has been explicitly set.
    var hasSupportsClientIntroductionAck: Bool {return _storage._supportsClientIntroductionAck != nil}
    /// Clears the value of `supportsClientIntroductionAck`. Subsequent reads from it will return its default value.
    mutating func clearSupportsClientIntroductionAck() {_uniqueStorage()._supportsClientIntroductionAck = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Should always match cs/symbol:location.nearby.proto.connections.Medium
    enum Medium: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case unknownMedium // = 0
      case mdns // = 1
      case bluetooth // = 2
      case wifiHotspot // = 3
      case ble // = 4
      case wifiLan // = 5
      case wifiAware // = 6
      case nfc // = 7
      case wifiDirect // = 8
      case webRtc // = 9

      /// 10 is reserved.
      case usb // = 11

      init() {
        self = .unknownMedium
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknownMedium
        case 1: self = .mdns
        case 2: self = .bluetooth
        case 3: self = .wifiHotspot
        case 4: self = .ble
        case 5: self = .wifiLan
        case 6: self = .wifiAware
        case 7: self = .nfc
        case 8: self = .wifiDirect
        case 9: self = .webRtc
        case 11: self = .usb
        default: return nil
        }
      }

      var rawValue: Int {
        switch self {
        case .unknownMedium: return 0
        case .mdns: return 1
        case .bluetooth: return 2
        case .wifiHotspot: return 3
        case .ble: return 4
        case .wifiLan: return 5
        case .wifiAware: return 6
        case .nfc: return 7
        case .wifiDirect: return 8
        case .webRtc: return 9
        case .usb: return 11
        }
      }

    }

    /// Accompanies Medium.WIFI_HOTSPOT.
    struct WifiHotspotCredentials {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var ssid: String {
        get {return _ssid ?? String()}
        set {_ssid = newValue}
      }
      /// Returns true if `ssid` has been explicitly set.
      var hasSsid: Bool {return self._ssid != nil}
      /// Clears the value of `ssid`. Subsequent reads from it will return its default value.
      mutating func clearSsid() {self._ssid = nil}

      var password: String {
        get {return _password ?? String()}
        set {_password = newValue}
      }
      /// Returns true if `password` has been explicitly set.
      var hasPassword: Bool {return self._password != nil}
      /// Clears the value of `password`. Subsequent reads from it will return its default value.
      mutating func clearPassword() {self._password = nil}

      var port: Int32 {
        get {return _port ?? 0}
        set {_port = newValue}
      }
      /// Returns true if `port` has been explicitly set.
      var hasPort: Bool {return self._port != nil}
      /// Clears the value of `port`. Subsequent reads from it will return its default value.
      mutating func clearPort() {self._port = nil}

      var gateway: String {
        get {return _gateway ?? "0.0.0.0"}
        set {_gateway = newValue}
      }
      /// Returns true if `gateway` has been explicitly set.
      var hasGateway: Bool {return self._gateway != nil}
      /// Clears the value of `gateway`. Subsequent reads from it will return its default value.
      mutating func clearGateway() {self._gateway = nil}

      /// This field can be a band or frequency
      var frequency: Int32 {
        get {return _frequency ?? -1}
        set {_frequency = newValue}
      }
      /// Returns true if `frequency` has been explicitly set.
      var hasFrequency: Bool {return self._frequency != nil}
      /// Clears the value of `frequency`. Subsequent reads from it will return its default value.
      mutating func clearFrequency() {self._frequency = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _ssid: String? = nil
      fileprivate var _password: String? = nil
      fileprivate var _port: Int32? = nil
      fileprivate var _gateway: String? = nil
      fileprivate var _frequency: Int32? = nil
    }

    /// Accompanies Medium.WIFI_LAN.
    struct WifiLanSocket {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var ipAddress: Data {
        get {return _ipAddress ?? Data()}
        set {_ipAddress = newValue}
      }
      /// Returns true if `ipAddress` has been explicitly set.
      var hasIpAddress: Bool {return self._ipAddress != nil}
      /// Clears the value of `ipAddress`. Subsequent reads from it will return its default value.
      mutating func clearIpAddress() {self._ipAddress = nil}

      var wifiPort: Int32 {
        get {return _wifiPort ?? 0}
        set {_wifiPort = newValue}
      }
      /// Returns true if `wifiPort` has been explicitly set.
      var hasWifiPort: Bool {return self._wifiPort != nil}
      /// Clears the value of `wifiPort`. Subsequent reads from it will return its default value.
      mutating func clearWifiPort() {self._wifiPort = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _ipAddress: Data? = nil
      fileprivate var _wifiPort: Int32? = nil
    }

    /// Accompanies Medium.BLUETOOTH.
    struct BluetoothCredentials {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var serviceName: String {
        get {return _serviceName ?? String()}
        set {_serviceName = newValue}
      }
      /// Returns true if `serviceName` has been explicitly set.
      var hasServiceName: Bool {return self._serviceName != nil}
      /// Clears the value of `serviceName`. Subsequent reads from it will return its default value.
      mutating func clearServiceName() {self._serviceName = nil}

      var macAddress: String {
        get {return _macAddress ?? String()}
        set {_macAddress = newValue}
      }
      /// Returns true if `macAddress` has been explicitly set.
      var hasMacAddress: Bool {return self._macAddress != nil}
      /// Clears the value of `macAddress`. Subsequent reads from it will return its default value.
      mutating func clearMacAddress() {self._macAddress = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _serviceName: String? = nil
      fileprivate var _macAddress: String? = nil
    }

    /// Accompanies Medium.WIFI_AWARE.
    struct WifiAwareCredentials {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var serviceID: String {
        get {return _serviceID ?? String()}
        set {_serviceID = newValue}
      }
      /// Returns true if `serviceID` has been explicitly set.
      var hasServiceID: Bool {return self._serviceID != nil}
      /// Clears the value of `serviceID`. Subsequent reads from it will return its default value.
      mutating func clearServiceID() {self._serviceID = nil}

      var serviceInfo: Data {
        get {return _serviceInfo ?? Data()}
        set {_serviceInfo = newValue}
      }
      /// Returns true if `serviceInfo` has been explicitly set.
      var hasServiceInfo: Bool {return self._serviceInfo != nil}
      /// Clears the value of `serviceInfo`. Subsequent reads from it will return its default value.
      mutating func clearServiceInfo() {self._serviceInfo = nil}

      var password: String {
        get {return _password ?? String()}
        set {_password = newValue}
      }
      /// Returns true if `password` has been explicitly set.
      var hasPassword: Bool {return self._password != nil}
      /// Clears the value of `password`. Subsequent reads from it will return its default value.
      mutating func clearPassword() {self._password = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _serviceID: String? = nil
      fileprivate var _serviceInfo: Data? = nil
      fileprivate var _password: String? = nil
    }

    /// Accompanies Medium.WIFI_DIRECT.
    struct WifiDirectCredentials {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var ssid: String {
        get {return _ssid ?? String()}
        set {_ssid = newValue}
      }
      /// Returns true if `ssid` has been explicitly set.
      var hasSsid: Bool {return self._ssid != nil}
      /// Clears the value of `ssid`. Subsequent reads from it will return its default value.
      mutating func clearSsid() {self._ssid = nil}

      var password: String {
        get {return _password ?? String()}
        set {_password = newValue}
      }
      /// Returns true if `password` has been explicitly set.
      var hasPassword: Bool {return self._password != nil}
      /// Clears the value of `password`. Subsequent reads from it will return its default value.
      mutating func clearPassword() {self._password = nil}

      var port: Int32 {
        get {return _port ?? 0}
        set {_port = newValue}
      }
      /// Returns true if `port` has been explicitly set.
      var hasPort: Bool {return self._port != nil}
      /// Clears the value of `port`. Subsequent reads from it will return its default value.
      mutating func clearPort() {self._port = nil}

      var frequency: Int32 {
        get {return _frequency ?? 0}
        set {_frequency = newValue}
      }
      /// Returns true if `frequency` has been explicitly set.
      var hasFrequency: Bool {return self._frequency != nil}
      /// Clears the value of `frequency`. Subsequent reads from it will return its default value.
      mutating func clearFrequency() {self._frequency = nil}

      var gateway: String {
        get {return _gateway ?? "0.0.0.0"}
        set {_gateway = newValue}
      }
      /// Returns true if `gateway` has been explicitly set.
      var hasGateway: Bool {return self._gateway != nil}
      /// Clears the value of `gateway`. Subsequent reads from it will return its default value.
      mutating func clearGateway() {self._gateway = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _ssid: String? = nil
      fileprivate var _password: String? = nil
      fileprivate var _port: Int32? = nil
      fileprivate var _frequency: Int32? = nil
      fileprivate var _gateway: String? = nil
    }

    /// Accompanies Medium.WEB_RTC
    struct WebRtcCredentials {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var peerID: String {
        get {return _peerID ?? String()}
        set {_peerID = newValue}
      }
      /// Returns true if `peerID` has been explicitly set.
      var hasPeerID: Bool {return self._peerID != nil}
      /// Clears the value of `peerID`. Subsequent reads from it will return its default value.
      mutating func clearPeerID() {self._peerID = nil}

      var locationHint: Location_Nearby_Connections_LocationHint {
        get {return _locationHint ?? Location_Nearby_Connections_LocationHint()}
        set {_locationHint = newValue}
      }
      /// Returns true if `locationHint` has been explicitly set.
      var hasLocationHint: Bool {return self._locationHint != nil}
      /// Clears the value of `locationHint`. Subsequent reads from it will return its default value.
      mutating func clearLocationHint() {self._locationHint = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _peerID: String? = nil
      fileprivate var _locationHint: Location_Nearby_Connections_LocationHint? = nil
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Accompanies CLIENT_INTRODUCTION events.
  struct ClientIntroduction {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var endpointID: String {
      get {return _endpointID ?? String()}
      set {_endpointID = newValue}
    }
    /// Returns true if `endpointID` has been explicitly set.
    var hasEndpointID: Bool {return self._endpointID != nil}
    /// Clears the value of `endpointID`. Subsequent reads from it will return its default value.
    mutating func clearEndpointID() {self._endpointID = nil}

    var supportsDisablingEncryption: Bool {
      get {return _supportsDisablingEncryption ?? false}
      set {_supportsDisablingEncryption = newValue}
    }
    /// Returns true if `supportsDisablingEncryption` has been explicitly set.
    var hasSupportsDisablingEncryption: Bool {return self._supportsDisablingEncryption != nil}
    /// Clears the value of `supportsDisablingEncryption`. Subsequent reads from it will return its default value.
    mutating func clearSupportsDisablingEncryption() {self._supportsDisablingEncryption = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _endpointID: String? = nil
    fileprivate var _supportsDisablingEncryption: Bool? = nil
  }

  /// Accompanies CLIENT_INTRODUCTION_ACK events.
  struct ClientIntroductionAck {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _eventType: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.EventType? = nil
  fileprivate var _upgradePathInfo: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo? = nil
  fileprivate var _clientIntroduction: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.ClientIntroduction? = nil
  fileprivate var _clientIntroductionAck: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.ClientIntroductionAck? = nil
}

#if swift(>=4.2)

extension Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.EventType: CaseIterable {
  // Support synthesized by the compiler.
}

extension Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.Medium: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Location_Nearby_Connections_KeepAliveFrame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// And ack will be sent after receiving KEEP_ALIVE frame.
  var ack: Bool {
    get {return _ack ?? false}
    set {_ack = newValue}
  }
  /// Returns true if `ack` has been explicitly set.
  var hasAck: Bool {return self._ack != nil}
  /// Clears the value of `ack`. Subsequent reads from it will return its default value.
  mutating func clearAck() {self._ack = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ack: Bool? = nil
}

/// Informs the remote side to immediately severe the socket connection.
/// Used in bandwidth upgrades to get around a race condition, but may be used
/// in other situations to trigger a faster disconnection event than waiting for
/// socket closed on the remote side.
struct Location_Nearby_Connections_DisconnectionFrame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Apply safe-to-disconnect protocol if true.
  var requestSafeToDisconnect: Bool {
    get {return _requestSafeToDisconnect ?? false}
    set {_requestSafeToDisconnect = newValue}
  }
  /// Returns true if `requestSafeToDisconnect` has been explicitly set.
  var hasRequestSafeToDisconnect: Bool {return self._requestSafeToDisconnect != nil}
  /// Clears the value of `requestSafeToDisconnect`. Subsequent reads from it will return its default value.
  mutating func clearRequestSafeToDisconnect() {self._requestSafeToDisconnect = nil}

  /// Ack of receiving Disconnection frame will be sent to the sender
  /// frame.
  var ackSafeToDisconnect: Bool {
    get {return _ackSafeToDisconnect ?? false}
    set {_ackSafeToDisconnect = newValue}
  }
  /// Returns true if `ackSafeToDisconnect` has been explicitly set.
  var hasAckSafeToDisconnect: Bool {return self._ackSafeToDisconnect != nil}
  /// Clears the value of `ackSafeToDisconnect`. Subsequent reads from it will return its default value.
  mutating func clearAckSafeToDisconnect() {self._ackSafeToDisconnect = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _requestSafeToDisconnect: Bool? = nil
  fileprivate var _ackSafeToDisconnect: Bool? = nil
}

/// A paired key encryption packet sent between devices, contains signed data.
struct Location_Nearby_Connections_PairedKeyEncryptionFrame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The encrypted data (raw authentication token for the established
  /// connection) in byte array format.
  var signedData: Data {
    get {return _signedData ?? Data()}
    set {_signedData = newValue}
  }
  /// Returns true if `signedData` has been explicitly set.
  var hasSignedData: Bool {return self._signedData != nil}
  /// Clears the value of `signedData`. Subsequent reads from it will return its default value.
  mutating func clearSignedData() {self._signedData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _signedData: Data? = nil
}

struct Location_Nearby_Connections_MediumMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// True if local device supports 5GHz.
  var supports5Ghz: Bool {
    get {return _supports5Ghz ?? false}
    set {_supports5Ghz = newValue}
  }
  /// Returns true if `supports5Ghz` has been explicitly set.
  var hasSupports5Ghz: Bool {return self._supports5Ghz != nil}
  /// Clears the value of `supports5Ghz`. Subsequent reads from it will return its default value.
  mutating func clearSupports5Ghz() {self._supports5Ghz = nil}

  /// WiFi LAN BSSID, in the form of a six-byte MAC address: XX:XX:XX:XX:XX:XX
  var bssid: String {
    get {return _bssid ?? String()}
    set {_bssid = newValue}
  }
  /// Returns true if `bssid` has been explicitly set.
  var hasBssid: Bool {return self._bssid != nil}
  /// Clears the value of `bssid`. Subsequent reads from it will return its default value.
  mutating func clearBssid() {self._bssid = nil}

  /// IP address, in network byte order: the highest order byte of the address is
  /// in byte[0].
  var ipAddress: Data {
    get {return _ipAddress ?? Data()}
    set {_ipAddress = newValue}
  }
  /// Returns true if `ipAddress` has been explicitly set.
  var hasIpAddress: Bool {return self._ipAddress != nil}
  /// Clears the value of `ipAddress`. Subsequent reads from it will return its default value.
  mutating func clearIpAddress() {self._ipAddress = nil}

  /// True if local device supports 6GHz.
  var supports6Ghz: Bool {
    get {return _supports6Ghz ?? false}
    set {_supports6Ghz = newValue}
  }
  /// Returns true if `supports6Ghz` has been explicitly set.
  var hasSupports6Ghz: Bool {return self._supports6Ghz != nil}
  /// Clears the value of `supports6Ghz`. Subsequent reads from it will return its default value.
  mutating func clearSupports6Ghz() {self._supports6Ghz = nil}

  /// True if local device has mobile radio.
  var mobileRadio: Bool {
    get {return _mobileRadio ?? false}
    set {_mobileRadio = newValue}
  }
  /// Returns true if `mobileRadio` has been explicitly set.
  var hasMobileRadio: Bool {return self._mobileRadio != nil}
  /// Clears the value of `mobileRadio`. Subsequent reads from it will return its default value.
  mutating func clearMobileRadio() {self._mobileRadio = nil}

  /// The frequency of the WiFi LAN AP(in MHz). Or -1 is not associated with an
  /// AP over WiFi, -2 represents the active network uses an Ethernet transport.
  var apFrequency: Int32 {
    get {return _apFrequency ?? -1}
    set {_apFrequency = newValue}
  }
  /// Returns true if `apFrequency` has been explicitly set.
  var hasApFrequency: Bool {return self._apFrequency != nil}
  /// Clears the value of `apFrequency`. Subsequent reads from it will return its default value.
  mutating func clearApFrequency() {self._apFrequency = nil}

  /// Available channels on the local device.
  var availableChannels: Location_Nearby_Connections_AvailableChannels {
    get {return _availableChannels ?? Location_Nearby_Connections_AvailableChannels()}
    set {_availableChannels = newValue}
  }
  /// Returns true if `availableChannels` has been explicitly set.
  var hasAvailableChannels: Bool {return self._availableChannels != nil}
  /// Clears the value of `availableChannels`. Subsequent reads from it will return its default value.
  mutating func clearAvailableChannels() {self._availableChannels = nil}

  /// Usable WiFi Direct client channels on the local device.
  var wifiDirectCliUsableChannels: Location_Nearby_Connections_WifiDirectCliUsableChannels {
    get {return _wifiDirectCliUsableChannels ?? Location_Nearby_Connections_WifiDirectCliUsableChannels()}
    set {_wifiDirectCliUsableChannels = newValue}
  }
  /// Returns true if `wifiDirectCliUsableChannels` has been explicitly set.
  var hasWifiDirectCliUsableChannels: Bool {return self._wifiDirectCliUsableChannels != nil}
  /// Clears the value of `wifiDirectCliUsableChannels`. Subsequent reads from it will return its default value.
  mutating func clearWifiDirectCliUsableChannels() {self._wifiDirectCliUsableChannels = nil}

  /// Usable WiFi LAN channels on the local device.
  var wifiLanUsableChannels: Location_Nearby_Connections_WifiLanUsableChannels {
    get {return _wifiLanUsableChannels ?? Location_Nearby_Connections_WifiLanUsableChannels()}
    set {_wifiLanUsableChannels = newValue}
  }
  /// Returns true if `wifiLanUsableChannels` has been explicitly set.
  var hasWifiLanUsableChannels: Bool {return self._wifiLanUsableChannels != nil}
  /// Clears the value of `wifiLanUsableChannels`. Subsequent reads from it will return its default value.
  mutating func clearWifiLanUsableChannels() {self._wifiLanUsableChannels = nil}

  /// Usable WiFi Aware channels on the local device.
  var wifiAwareUsableChannels: Location_Nearby_Connections_WifiAwareUsableChannels {
    get {return _wifiAwareUsableChannels ?? Location_Nearby_Connections_WifiAwareUsableChannels()}
    set {_wifiAwareUsableChannels = newValue}
  }
  /// Returns true if `wifiAwareUsableChannels` has been explicitly set.
  var hasWifiAwareUsableChannels: Bool {return self._wifiAwareUsableChannels != nil}
  /// Clears the value of `wifiAwareUsableChannels`. Subsequent reads from it will return its default value.
  mutating func clearWifiAwareUsableChannels() {self._wifiAwareUsableChannels = nil}

  /// Usable WiFi Hotspot STA channels on the local device.
  var wifiHotspotStaUsableChannels: Location_Nearby_Connections_WifiHotspotStaUsableChannels {
    get {return _wifiHotspotStaUsableChannels ?? Location_Nearby_Connections_WifiHotspotStaUsableChannels()}
    set {_wifiHotspotStaUsableChannels = newValue}
  }
  /// Returns true if `wifiHotspotStaUsableChannels` has been explicitly set.
  var hasWifiHotspotStaUsableChannels: Bool {return self._wifiHotspotStaUsableChannels != nil}
  /// Clears the value of `wifiHotspotStaUsableChannels`. Subsequent reads from it will return its default value.
  mutating func clearWifiHotspotStaUsableChannels() {self._wifiHotspotStaUsableChannels = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _supports5Ghz: Bool? = nil
  fileprivate var _bssid: String? = nil
  fileprivate var _ipAddress: Data? = nil
  fileprivate var _supports6Ghz: Bool? = nil
  fileprivate var _mobileRadio: Bool? = nil
  fileprivate var _apFrequency: Int32? = nil
  fileprivate var _availableChannels: Location_Nearby_Connections_AvailableChannels? = nil
  fileprivate var _wifiDirectCliUsableChannels: Location_Nearby_Connections_WifiDirectCliUsableChannels? = nil
  fileprivate var _wifiLanUsableChannels: Location_Nearby_Connections_WifiLanUsableChannels? = nil
  fileprivate var _wifiAwareUsableChannels: Location_Nearby_Connections_WifiAwareUsableChannels? = nil
  fileprivate var _wifiHotspotStaUsableChannels: Location_Nearby_Connections_WifiHotspotStaUsableChannels? = nil
}

/// Available channels on the local device.
struct Location_Nearby_Connections_AvailableChannels {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channels: [Int32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Usable WiFi Direct client channels on the local device.
struct Location_Nearby_Connections_WifiDirectCliUsableChannels {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channels: [Int32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Usable WiFi LAN channels on the local device.
struct Location_Nearby_Connections_WifiLanUsableChannels {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channels: [Int32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Usable WiFi Aware channels on the local device.
struct Location_Nearby_Connections_WifiAwareUsableChannels {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channels: [Int32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Usable WiFi Hotspot STA channels on the local device.
struct Location_Nearby_Connections_WifiHotspotStaUsableChannels {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channels: [Int32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// LocationHint is used to specify a location as well as format.
struct Location_Nearby_Connections_LocationHint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Location is the location, provided in the format specified by format.
  var location: String {
    get {return _location ?? String()}
    set {_location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  var hasLocation: Bool {return self._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  mutating func clearLocation() {self._location = nil}

  /// the format of location.
  var format: Location_Nearby_Connections_LocationStandard.Format {
    get {return _format ?? .unknown}
    set {_format = newValue}
  }
  /// Returns true if `format` has been explicitly set.
  var hasFormat: Bool {return self._format != nil}
  /// Clears the value of `format`. Subsequent reads from it will return its default value.
  mutating func clearFormat() {self._format = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _location: String? = nil
  fileprivate var _format: Location_Nearby_Connections_LocationStandard.Format? = nil
}

struct Location_Nearby_Connections_LocationStandard {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Format: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0

    /// E164 country codes:
    /// https://en.wikipedia.org/wiki/List_of_country_calling_codes
    /// e.g. +1 for USA
    case e164Calling // = 1

    /// ISO 3166-1 alpha-2 country codes:
    /// https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2
    case iso31661Alpha2 // = 2

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .e164Calling
      case 2: self = .iso31661Alpha2
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .e164Calling: return 1
      case .iso31661Alpha2: return 2
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Location_Nearby_Connections_LocationStandard.Format: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// Device capability for OS information.
struct Location_Nearby_Connections_OsInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Location_Nearby_Connections_OsInfo.OsType {
    get {return _type ?? .unknownOsType}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OsType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknownOsType // = 0
    case android // = 1
    case chromeOs // = 2
    case windows // = 3
    case apple // = 4

    /// g3 test environment
    case linux // = 100

    init() {
      self = .unknownOsType
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownOsType
      case 1: self = .android
      case 2: self = .chromeOs
      case 3: self = .windows
      case 4: self = .apple
      case 100: self = .linux
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknownOsType: return 0
      case .android: return 1
      case .chromeOs: return 2
      case .windows: return 3
      case .apple: return 4
      case .linux: return 100
      }
    }

  }

  init() {}

  fileprivate var _type: Location_Nearby_Connections_OsInfo.OsType? = nil
}

#if swift(>=4.2)

extension Location_Nearby_Connections_OsInfo.OsType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension Location_Nearby_Connections_OfflineFrame: @unchecked Sendable {}
extension Location_Nearby_Connections_OfflineFrame.Version: @unchecked Sendable {}
extension Location_Nearby_Connections_V1Frame: @unchecked Sendable {}
extension Location_Nearby_Connections_V1Frame.FrameType: @unchecked Sendable {}
extension Location_Nearby_Connections_ConnectionRequestFrame: @unchecked Sendable {}
extension Location_Nearby_Connections_ConnectionRequestFrame.Medium: @unchecked Sendable {}
extension Location_Nearby_Connections_ConnectionResponseFrame: @unchecked Sendable {}
extension Location_Nearby_Connections_ConnectionResponseFrame.ResponseStatus: @unchecked Sendable {}
extension Location_Nearby_Connections_PayloadTransferFrame: @unchecked Sendable {}
extension Location_Nearby_Connections_PayloadTransferFrame.PacketType: @unchecked Sendable {}
extension Location_Nearby_Connections_PayloadTransferFrame.PayloadHeader: @unchecked Sendable {}
extension Location_Nearby_Connections_PayloadTransferFrame.PayloadHeader.PayloadType: @unchecked Sendable {}
extension Location_Nearby_Connections_PayloadTransferFrame.PayloadChunk: @unchecked Sendable {}
extension Location_Nearby_Connections_PayloadTransferFrame.PayloadChunk.Flags: @unchecked Sendable {}
extension Location_Nearby_Connections_PayloadTransferFrame.ControlMessage: @unchecked Sendable {}
extension Location_Nearby_Connections_PayloadTransferFrame.ControlMessage.EventType: @unchecked Sendable {}
extension Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame: @unchecked Sendable {}
extension Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.EventType: @unchecked Sendable {}
extension Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo: @unchecked Sendable {}
extension Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.Medium: @unchecked Sendable {}
extension Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials: @unchecked Sendable {}
extension Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket: @unchecked Sendable {}
extension Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials: @unchecked Sendable {}
extension Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials: @unchecked Sendable {}
extension Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials: @unchecked Sendable {}
extension Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials: @unchecked Sendable {}
extension Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.ClientIntroduction: @unchecked Sendable {}
extension Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.ClientIntroductionAck: @unchecked Sendable {}
extension Location_Nearby_Connections_KeepAliveFrame: @unchecked Sendable {}
extension Location_Nearby_Connections_DisconnectionFrame: @unchecked Sendable {}
extension Location_Nearby_Connections_PairedKeyEncryptionFrame: @unchecked Sendable {}
extension Location_Nearby_Connections_MediumMetadata: @unchecked Sendable {}
extension Location_Nearby_Connections_AvailableChannels: @unchecked Sendable {}
extension Location_Nearby_Connections_WifiDirectCliUsableChannels: @unchecked Sendable {}
extension Location_Nearby_Connections_WifiLanUsableChannels: @unchecked Sendable {}
extension Location_Nearby_Connections_WifiAwareUsableChannels: @unchecked Sendable {}
extension Location_Nearby_Connections_WifiHotspotStaUsableChannels: @unchecked Sendable {}
extension Location_Nearby_Connections_LocationHint: @unchecked Sendable {}
extension Location_Nearby_Connections_LocationStandard: @unchecked Sendable {}
extension Location_Nearby_Connections_LocationStandard.Format: @unchecked Sendable {}
extension Location_Nearby_Connections_OsInfo: @unchecked Sendable {}
extension Location_Nearby_Connections_OsInfo.OsType: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "location.nearby.connections"

extension Location_Nearby_Connections_OfflineFrame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OfflineFrame"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "v1"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._version) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._v1) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._version {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._v1 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Location_Nearby_Connections_OfflineFrame, rhs: Location_Nearby_Connections_OfflineFrame) -> Bool {
    if lhs._version != rhs._version {return false}
    if lhs._v1 != rhs._v1 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Location_Nearby_Connections_OfflineFrame.Version: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_VERSION"),
    1: .same(proto: "V1"),
  ]
}

extension Location_Nearby_Connections_V1Frame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".V1Frame"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "connection_request"),
    3: .standard(proto: "connection_response"),
    4: .standard(proto: "payload_transfer"),
    5: .standard(proto: "bandwidth_upgrade_negotiation"),
    6: .standard(proto: "keep_alive"),
    7: .same(proto: "disconnection"),
    8: .standard(proto: "paired_key_encryption"),
  ]

  fileprivate class _StorageClass {
    var _type: Location_Nearby_Connections_V1Frame.FrameType? = nil
    var _connectionRequest: Location_Nearby_Connections_ConnectionRequestFrame? = nil
    var _connectionResponse: Location_Nearby_Connections_ConnectionResponseFrame? = nil
    var _payloadTransfer: Location_Nearby_Connections_PayloadTransferFrame? = nil
    var _bandwidthUpgradeNegotiation: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame? = nil
    var _keepAlive: Location_Nearby_Connections_KeepAliveFrame? = nil
    var _disconnection: Location_Nearby_Connections_DisconnectionFrame? = nil
    var _pairedKeyEncryption: Location_Nearby_Connections_PairedKeyEncryptionFrame? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _connectionRequest = source._connectionRequest
      _connectionResponse = source._connectionResponse
      _payloadTransfer = source._payloadTransfer
      _bandwidthUpgradeNegotiation = source._bandwidthUpgradeNegotiation
      _keepAlive = source._keepAlive
      _disconnection = source._disconnection
      _pairedKeyEncryption = source._pairedKeyEncryption
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._connectionRequest) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._connectionResponse) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._payloadTransfer) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._bandwidthUpgradeNegotiation) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._keepAlive) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._disconnection) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._pairedKeyEncryption) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._type {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._connectionRequest {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._connectionResponse {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._payloadTransfer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._bandwidthUpgradeNegotiation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._keepAlive {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._disconnection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._pairedKeyEncryption {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Location_Nearby_Connections_V1Frame, rhs: Location_Nearby_Connections_V1Frame) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._connectionRequest != rhs_storage._connectionRequest {return false}
        if _storage._connectionResponse != rhs_storage._connectionResponse {return false}
        if _storage._payloadTransfer != rhs_storage._payloadTransfer {return false}
        if _storage._bandwidthUpgradeNegotiation != rhs_storage._bandwidthUpgradeNegotiation {return false}
        if _storage._keepAlive != rhs_storage._keepAlive {return false}
        if _storage._disconnection != rhs_storage._disconnection {return false}
        if _storage._pairedKeyEncryption != rhs_storage._pairedKeyEncryption {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Location_Nearby_Connections_V1Frame.FrameType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_FRAME_TYPE"),
    1: .same(proto: "CONNECTION_REQUEST"),
    2: .same(proto: "CONNECTION_RESPONSE"),
    3: .same(proto: "PAYLOAD_TRANSFER"),
    4: .same(proto: "BANDWIDTH_UPGRADE_NEGOTIATION"),
    5: .same(proto: "KEEP_ALIVE"),
    6: .same(proto: "DISCONNECTION"),
    7: .same(proto: "PAIRED_KEY_ENCRYPTION"),
  ]
}

extension Location_Nearby_Connections_ConnectionRequestFrame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectionRequestFrame"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "endpoint_id"),
    2: .standard(proto: "endpoint_name"),
    3: .standard(proto: "handshake_data"),
    4: .same(proto: "nonce"),
    5: .same(proto: "mediums"),
    6: .standard(proto: "endpoint_info"),
    7: .standard(proto: "medium_metadata"),
    8: .standard(proto: "keep_alive_interval_millis"),
    9: .standard(proto: "keep_alive_timeout_millis"),
    10: .standard(proto: "device_type"),
    11: .standard(proto: "device_info"),
  ]

  fileprivate class _StorageClass {
    var _endpointID: String? = nil
    var _endpointName: String? = nil
    var _handshakeData: Data? = nil
    var _nonce: Int32? = nil
    var _mediums: [Location_Nearby_Connections_ConnectionRequestFrame.Medium] = []
    var _endpointInfo: Data? = nil
    var _mediumMetadata: Location_Nearby_Connections_MediumMetadata? = nil
    var _keepAliveIntervalMillis: Int32? = nil
    var _keepAliveTimeoutMillis: Int32? = nil
    var _deviceType: Int32? = nil
    var _deviceInfo: Data? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _endpointID = source._endpointID
      _endpointName = source._endpointName
      _handshakeData = source._handshakeData
      _nonce = source._nonce
      _mediums = source._mediums
      _endpointInfo = source._endpointInfo
      _mediumMetadata = source._mediumMetadata
      _keepAliveIntervalMillis = source._keepAliveIntervalMillis
      _keepAliveTimeoutMillis = source._keepAliveTimeoutMillis
      _deviceType = source._deviceType
      _deviceInfo = source._deviceInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._endpointID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._endpointName) }()
        case 3: try { try decoder.decodeSingularBytesField(value: &_storage._handshakeData) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._nonce) }()
        case 5: try { try decoder.decodeRepeatedEnumField(value: &_storage._mediums) }()
        case 6: try { try decoder.decodeSingularBytesField(value: &_storage._endpointInfo) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._mediumMetadata) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._keepAliveIntervalMillis) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._keepAliveTimeoutMillis) }()
        case 10: try { try decoder.decodeSingularInt32Field(value: &_storage._deviceType) }()
        case 11: try { try decoder.decodeSingularBytesField(value: &_storage._deviceInfo) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._endpointID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._endpointName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._handshakeData {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._nonce {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
      } }()
      if !_storage._mediums.isEmpty {
        try visitor.visitRepeatedEnumField(value: _storage._mediums, fieldNumber: 5)
      }
      try { if let v = _storage._endpointInfo {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._mediumMetadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._keepAliveIntervalMillis {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._keepAliveTimeoutMillis {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._deviceType {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._deviceInfo {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 11)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Location_Nearby_Connections_ConnectionRequestFrame, rhs: Location_Nearby_Connections_ConnectionRequestFrame) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._endpointID != rhs_storage._endpointID {return false}
        if _storage._endpointName != rhs_storage._endpointName {return false}
        if _storage._handshakeData != rhs_storage._handshakeData {return false}
        if _storage._nonce != rhs_storage._nonce {return false}
        if _storage._mediums != rhs_storage._mediums {return false}
        if _storage._endpointInfo != rhs_storage._endpointInfo {return false}
        if _storage._mediumMetadata != rhs_storage._mediumMetadata {return false}
        if _storage._keepAliveIntervalMillis != rhs_storage._keepAliveIntervalMillis {return false}
        if _storage._keepAliveTimeoutMillis != rhs_storage._keepAliveTimeoutMillis {return false}
        if _storage._deviceType != rhs_storage._deviceType {return false}
        if _storage._deviceInfo != rhs_storage._deviceInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Location_Nearby_Connections_ConnectionRequestFrame.Medium: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_MEDIUM"),
    1: .same(proto: "MDNS"),
    2: .same(proto: "BLUETOOTH"),
    3: .same(proto: "WIFI_HOTSPOT"),
    4: .same(proto: "BLE"),
    5: .same(proto: "WIFI_LAN"),
    6: .same(proto: "WIFI_AWARE"),
    7: .same(proto: "NFC"),
    8: .same(proto: "WIFI_DIRECT"),
    9: .same(proto: "WEB_RTC"),
    10: .same(proto: "BLE_L2CAP"),
    11: .same(proto: "USB"),
  ]
}

extension Location_Nearby_Connections_ConnectionResponseFrame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectionResponseFrame"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "handshake_data"),
    3: .same(proto: "response"),
    4: .standard(proto: "os_info"),
    5: .standard(proto: "multiplex_socket_bitmask"),
    6: .standard(proto: "nearby_connections_version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._status) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._handshakeData) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._response) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._osInfo) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._multiplexSocketBitmask) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self._nearbyConnectionsVersion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._handshakeData {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._response {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._osInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._multiplexSocketBitmask {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._nearbyConnectionsVersion {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Location_Nearby_Connections_ConnectionResponseFrame, rhs: Location_Nearby_Connections_ConnectionResponseFrame) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._handshakeData != rhs._handshakeData {return false}
    if lhs._response != rhs._response {return false}
    if lhs._osInfo != rhs._osInfo {return false}
    if lhs._multiplexSocketBitmask != rhs._multiplexSocketBitmask {return false}
    if lhs._nearbyConnectionsVersion != rhs._nearbyConnectionsVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Location_Nearby_Connections_ConnectionResponseFrame.ResponseStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_RESPONSE_STATUS"),
    1: .same(proto: "ACCEPT"),
    2: .same(proto: "REJECT"),
  ]
}

extension Location_Nearby_Connections_PayloadTransferFrame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PayloadTransferFrame"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "packet_type"),
    2: .standard(proto: "payload_header"),
    3: .standard(proto: "payload_chunk"),
    4: .standard(proto: "control_message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._packetType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._payloadHeader) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._payloadChunk) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._controlMessage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._packetType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._payloadHeader {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._payloadChunk {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._controlMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Location_Nearby_Connections_PayloadTransferFrame, rhs: Location_Nearby_Connections_PayloadTransferFrame) -> Bool {
    if lhs._packetType != rhs._packetType {return false}
    if lhs._payloadHeader != rhs._payloadHeader {return false}
    if lhs._payloadChunk != rhs._payloadChunk {return false}
    if lhs._controlMessage != rhs._controlMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Location_Nearby_Connections_PayloadTransferFrame.PacketType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_PACKET_TYPE"),
    1: .same(proto: "DATA"),
    2: .same(proto: "CONTROL"),
  ]
}

extension Location_Nearby_Connections_PayloadTransferFrame.PayloadHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Location_Nearby_Connections_PayloadTransferFrame.protoMessageName + ".PayloadHeader"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .standard(proto: "total_size"),
    4: .standard(proto: "is_sensitive"),
    5: .standard(proto: "file_name"),
    6: .standard(proto: "parent_folder"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self._totalSize) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._isSensitive) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._fileName) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._parentFolder) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._totalSize {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._isSensitive {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._fileName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._parentFolder {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Location_Nearby_Connections_PayloadTransferFrame.PayloadHeader, rhs: Location_Nearby_Connections_PayloadTransferFrame.PayloadHeader) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._type != rhs._type {return false}
    if lhs._totalSize != rhs._totalSize {return false}
    if lhs._isSensitive != rhs._isSensitive {return false}
    if lhs._fileName != rhs._fileName {return false}
    if lhs._parentFolder != rhs._parentFolder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Location_Nearby_Connections_PayloadTransferFrame.PayloadHeader.PayloadType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_PAYLOAD_TYPE"),
    1: .same(proto: "BYTES"),
    2: .same(proto: "FILE"),
    3: .same(proto: "STREAM"),
  ]
}

extension Location_Nearby_Connections_PayloadTransferFrame.PayloadChunk: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Location_Nearby_Connections_PayloadTransferFrame.protoMessageName + ".PayloadChunk"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "flags"),
    2: .same(proto: "offset"),
    3: .same(proto: "body"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._flags) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self._offset) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._body) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._flags {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._offset {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._body {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Location_Nearby_Connections_PayloadTransferFrame.PayloadChunk, rhs: Location_Nearby_Connections_PayloadTransferFrame.PayloadChunk) -> Bool {
    if lhs._flags != rhs._flags {return false}
    if lhs._offset != rhs._offset {return false}
    if lhs._body != rhs._body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Location_Nearby_Connections_PayloadTransferFrame.PayloadChunk.Flags: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "LAST_CHUNK"),
  ]
}

extension Location_Nearby_Connections_PayloadTransferFrame.ControlMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Location_Nearby_Connections_PayloadTransferFrame.protoMessageName + ".ControlMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "event"),
    2: .same(proto: "offset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._event) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self._offset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._event {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._offset {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Location_Nearby_Connections_PayloadTransferFrame.ControlMessage, rhs: Location_Nearby_Connections_PayloadTransferFrame.ControlMessage) -> Bool {
    if lhs._event != rhs._event {return false}
    if lhs._offset != rhs._offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Location_Nearby_Connections_PayloadTransferFrame.ControlMessage.EventType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_EVENT_TYPE"),
    1: .same(proto: "PAYLOAD_ERROR"),
    2: .same(proto: "PAYLOAD_CANCELED"),
    3: .same(proto: "PAYLOAD_RECEIVED_ACK"),
  ]
}

extension Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BandwidthUpgradeNegotiationFrame"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_type"),
    2: .standard(proto: "upgrade_path_info"),
    3: .standard(proto: "client_introduction"),
    4: .standard(proto: "client_introduction_ack"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._eventType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._upgradePathInfo) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._clientIntroduction) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._clientIntroductionAck) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._eventType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._upgradePathInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._clientIntroduction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._clientIntroductionAck {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame, rhs: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame) -> Bool {
    if lhs._eventType != rhs._eventType {return false}
    if lhs._upgradePathInfo != rhs._upgradePathInfo {return false}
    if lhs._clientIntroduction != rhs._clientIntroduction {return false}
    if lhs._clientIntroductionAck != rhs._clientIntroductionAck {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.EventType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_EVENT_TYPE"),
    1: .same(proto: "UPGRADE_PATH_AVAILABLE"),
    2: .same(proto: "LAST_WRITE_TO_PRIOR_CHANNEL"),
    3: .same(proto: "SAFE_TO_CLOSE_PRIOR_CHANNEL"),
    4: .same(proto: "CLIENT_INTRODUCTION"),
    5: .same(proto: "UPGRADE_FAILURE"),
    6: .same(proto: "CLIENT_INTRODUCTION_ACK"),
  ]
}

extension Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.protoMessageName + ".UpgradePathInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "medium"),
    2: .standard(proto: "wifi_hotspot_credentials"),
    3: .standard(proto: "wifi_lan_socket"),
    4: .standard(proto: "bluetooth_credentials"),
    5: .standard(proto: "wifi_aware_credentials"),
    6: .standard(proto: "wifi_direct_credentials"),
    8: .standard(proto: "web_rtc_credentials"),
    7: .standard(proto: "supports_disabling_encryption"),
    9: .standard(proto: "supports_client_introduction_ack"),
  ]

  fileprivate class _StorageClass {
    var _medium: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.Medium? = nil
    var _wifiHotspotCredentials: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials? = nil
    var _wifiLanSocket: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket? = nil
    var _bluetoothCredentials: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials? = nil
    var _wifiAwareCredentials: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials? = nil
    var _wifiDirectCredentials: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials? = nil
    var _webRtcCredentials: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials? = nil
    var _supportsDisablingEncryption: Bool? = nil
    var _supportsClientIntroductionAck: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _medium = source._medium
      _wifiHotspotCredentials = source._wifiHotspotCredentials
      _wifiLanSocket = source._wifiLanSocket
      _bluetoothCredentials = source._bluetoothCredentials
      _wifiAwareCredentials = source._wifiAwareCredentials
      _wifiDirectCredentials = source._wifiDirectCredentials
      _webRtcCredentials = source._webRtcCredentials
      _supportsDisablingEncryption = source._supportsDisablingEncryption
      _supportsClientIntroductionAck = source._supportsClientIntroductionAck
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._medium) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._wifiHotspotCredentials) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._wifiLanSocket) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._bluetoothCredentials) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._wifiAwareCredentials) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._wifiDirectCredentials) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._supportsDisablingEncryption) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._webRtcCredentials) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._supportsClientIntroductionAck) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._medium {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._wifiHotspotCredentials {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._wifiLanSocket {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._bluetoothCredentials {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._wifiAwareCredentials {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._wifiDirectCredentials {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._supportsDisablingEncryption {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._webRtcCredentials {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._supportsClientIntroductionAck {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo, rhs: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._medium != rhs_storage._medium {return false}
        if _storage._wifiHotspotCredentials != rhs_storage._wifiHotspotCredentials {return false}
        if _storage._wifiLanSocket != rhs_storage._wifiLanSocket {return false}
        if _storage._bluetoothCredentials != rhs_storage._bluetoothCredentials {return false}
        if _storage._wifiAwareCredentials != rhs_storage._wifiAwareCredentials {return false}
        if _storage._wifiDirectCredentials != rhs_storage._wifiDirectCredentials {return false}
        if _storage._webRtcCredentials != rhs_storage._webRtcCredentials {return false}
        if _storage._supportsDisablingEncryption != rhs_storage._supportsDisablingEncryption {return false}
        if _storage._supportsClientIntroductionAck != rhs_storage._supportsClientIntroductionAck {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.Medium: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_MEDIUM"),
    1: .same(proto: "MDNS"),
    2: .same(proto: "BLUETOOTH"),
    3: .same(proto: "WIFI_HOTSPOT"),
    4: .same(proto: "BLE"),
    5: .same(proto: "WIFI_LAN"),
    6: .same(proto: "WIFI_AWARE"),
    7: .same(proto: "NFC"),
    8: .same(proto: "WIFI_DIRECT"),
    9: .same(proto: "WEB_RTC"),
    11: .same(proto: "USB"),
  ]
}

extension Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.protoMessageName + ".WifiHotspotCredentials"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ssid"),
    2: .same(proto: "password"),
    3: .same(proto: "port"),
    4: .same(proto: "gateway"),
    5: .same(proto: "frequency"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._ssid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._password) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._port) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._gateway) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._frequency) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ssid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._password {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._port {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._gateway {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._frequency {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials, rhs: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials) -> Bool {
    if lhs._ssid != rhs._ssid {return false}
    if lhs._password != rhs._password {return false}
    if lhs._port != rhs._port {return false}
    if lhs._gateway != rhs._gateway {return false}
    if lhs._frequency != rhs._frequency {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.protoMessageName + ".WifiLanSocket"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ip_address"),
    2: .standard(proto: "wifi_port"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._ipAddress) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._wifiPort) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ipAddress {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._wifiPort {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket, rhs: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket) -> Bool {
    if lhs._ipAddress != rhs._ipAddress {return false}
    if lhs._wifiPort != rhs._wifiPort {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.protoMessageName + ".BluetoothCredentials"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "service_name"),
    2: .standard(proto: "mac_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._serviceName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._macAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._serviceName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._macAddress {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials, rhs: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials) -> Bool {
    if lhs._serviceName != rhs._serviceName {return false}
    if lhs._macAddress != rhs._macAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.protoMessageName + ".WifiAwareCredentials"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "service_id"),
    2: .standard(proto: "service_info"),
    3: .same(proto: "password"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._serviceID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._serviceInfo) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._password) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._serviceID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._serviceInfo {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._password {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials, rhs: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials) -> Bool {
    if lhs._serviceID != rhs._serviceID {return false}
    if lhs._serviceInfo != rhs._serviceInfo {return false}
    if lhs._password != rhs._password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.protoMessageName + ".WifiDirectCredentials"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ssid"),
    2: .same(proto: "password"),
    3: .same(proto: "port"),
    4: .same(proto: "frequency"),
    5: .same(proto: "gateway"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._ssid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._password) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._port) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._frequency) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._gateway) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ssid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._password {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._port {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._frequency {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._gateway {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials, rhs: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials) -> Bool {
    if lhs._ssid != rhs._ssid {return false}
    if lhs._password != rhs._password {return false}
    if lhs._port != rhs._port {return false}
    if lhs._frequency != rhs._frequency {return false}
    if lhs._gateway != rhs._gateway {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.protoMessageName + ".WebRtcCredentials"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "peer_id"),
    2: .standard(proto: "location_hint"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._peerID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._locationHint) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._peerID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._locationHint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials, rhs: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials) -> Bool {
    if lhs._peerID != rhs._peerID {return false}
    if lhs._locationHint != rhs._locationHint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.ClientIntroduction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.protoMessageName + ".ClientIntroduction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "endpoint_id"),
    2: .standard(proto: "supports_disabling_encryption"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._endpointID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._supportsDisablingEncryption) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._endpointID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._supportsDisablingEncryption {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.ClientIntroduction, rhs: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.ClientIntroduction) -> Bool {
    if lhs._endpointID != rhs._endpointID {return false}
    if lhs._supportsDisablingEncryption != rhs._supportsDisablingEncryption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.ClientIntroductionAck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.protoMessageName + ".ClientIntroductionAck"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.ClientIntroductionAck, rhs: Location_Nearby_Connections_BandwidthUpgradeNegotiationFrame.ClientIntroductionAck) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Location_Nearby_Connections_KeepAliveFrame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeepAliveFrame"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ack"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._ack) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ack {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Location_Nearby_Connections_KeepAliveFrame, rhs: Location_Nearby_Connections_KeepAliveFrame) -> Bool {
    if lhs._ack != rhs._ack {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Location_Nearby_Connections_DisconnectionFrame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisconnectionFrame"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_safe_to_disconnect"),
    2: .standard(proto: "ack_safe_to_disconnect"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._requestSafeToDisconnect) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._ackSafeToDisconnect) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requestSafeToDisconnect {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._ackSafeToDisconnect {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Location_Nearby_Connections_DisconnectionFrame, rhs: Location_Nearby_Connections_DisconnectionFrame) -> Bool {
    if lhs._requestSafeToDisconnect != rhs._requestSafeToDisconnect {return false}
    if lhs._ackSafeToDisconnect != rhs._ackSafeToDisconnect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Location_Nearby_Connections_PairedKeyEncryptionFrame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PairedKeyEncryptionFrame"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "signed_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._signedData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._signedData {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Location_Nearby_Connections_PairedKeyEncryptionFrame, rhs: Location_Nearby_Connections_PairedKeyEncryptionFrame) -> Bool {
    if lhs._signedData != rhs._signedData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Location_Nearby_Connections_MediumMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MediumMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "supports_5_ghz"),
    2: .same(proto: "bssid"),
    3: .standard(proto: "ip_address"),
    4: .standard(proto: "supports_6_ghz"),
    5: .standard(proto: "mobile_radio"),
    6: .standard(proto: "ap_frequency"),
    7: .standard(proto: "available_channels"),
    8: .standard(proto: "wifi_direct_cli_usable_channels"),
    9: .standard(proto: "wifi_lan_usable_channels"),
    10: .standard(proto: "wifi_aware_usable_channels"),
    11: .standard(proto: "wifi_hotspot_sta_usable_channels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._supports5Ghz) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._bssid) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._ipAddress) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._supports6Ghz) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._mobileRadio) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self._apFrequency) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._availableChannels) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._wifiDirectCliUsableChannels) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._wifiLanUsableChannels) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._wifiAwareUsableChannels) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._wifiHotspotStaUsableChannels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._supports5Ghz {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._bssid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._ipAddress {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._supports6Ghz {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._mobileRadio {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._apFrequency {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._availableChannels {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._wifiDirectCliUsableChannels {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._wifiLanUsableChannels {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._wifiAwareUsableChannels {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._wifiHotspotStaUsableChannels {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Location_Nearby_Connections_MediumMetadata, rhs: Location_Nearby_Connections_MediumMetadata) -> Bool {
    if lhs._supports5Ghz != rhs._supports5Ghz {return false}
    if lhs._bssid != rhs._bssid {return false}
    if lhs._ipAddress != rhs._ipAddress {return false}
    if lhs._supports6Ghz != rhs._supports6Ghz {return false}
    if lhs._mobileRadio != rhs._mobileRadio {return false}
    if lhs._apFrequency != rhs._apFrequency {return false}
    if lhs._availableChannels != rhs._availableChannels {return false}
    if lhs._wifiDirectCliUsableChannels != rhs._wifiDirectCliUsableChannels {return false}
    if lhs._wifiLanUsableChannels != rhs._wifiLanUsableChannels {return false}
    if lhs._wifiAwareUsableChannels != rhs._wifiAwareUsableChannels {return false}
    if lhs._wifiHotspotStaUsableChannels != rhs._wifiHotspotStaUsableChannels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Location_Nearby_Connections_AvailableChannels: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AvailableChannels"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt32Field(value: &self.channels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channels.isEmpty {
      try visitor.visitPackedInt32Field(value: self.channels, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Location_Nearby_Connections_AvailableChannels, rhs: Location_Nearby_Connections_AvailableChannels) -> Bool {
    if lhs.channels != rhs.channels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Location_Nearby_Connections_WifiDirectCliUsableChannels: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WifiDirectCliUsableChannels"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt32Field(value: &self.channels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channels.isEmpty {
      try visitor.visitPackedInt32Field(value: self.channels, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Location_Nearby_Connections_WifiDirectCliUsableChannels, rhs: Location_Nearby_Connections_WifiDirectCliUsableChannels) -> Bool {
    if lhs.channels != rhs.channels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Location_Nearby_Connections_WifiLanUsableChannels: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WifiLanUsableChannels"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt32Field(value: &self.channels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channels.isEmpty {
      try visitor.visitPackedInt32Field(value: self.channels, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Location_Nearby_Connections_WifiLanUsableChannels, rhs: Location_Nearby_Connections_WifiLanUsableChannels) -> Bool {
    if lhs.channels != rhs.channels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Location_Nearby_Connections_WifiAwareUsableChannels: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WifiAwareUsableChannels"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt32Field(value: &self.channels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channels.isEmpty {
      try visitor.visitPackedInt32Field(value: self.channels, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Location_Nearby_Connections_WifiAwareUsableChannels, rhs: Location_Nearby_Connections_WifiAwareUsableChannels) -> Bool {
    if lhs.channels != rhs.channels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Location_Nearby_Connections_WifiHotspotStaUsableChannels: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WifiHotspotStaUsableChannels"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt32Field(value: &self.channels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channels.isEmpty {
      try visitor.visitPackedInt32Field(value: self.channels, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Location_Nearby_Connections_WifiHotspotStaUsableChannels, rhs: Location_Nearby_Connections_WifiHotspotStaUsableChannels) -> Bool {
    if lhs.channels != rhs.channels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Location_Nearby_Connections_LocationHint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LocationHint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "location"),
    2: .same(proto: "format"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._location) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._format) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._location {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._format {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Location_Nearby_Connections_LocationHint, rhs: Location_Nearby_Connections_LocationHint) -> Bool {
    if lhs._location != rhs._location {return false}
    if lhs._format != rhs._format {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Location_Nearby_Connections_LocationStandard: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LocationStandard"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Location_Nearby_Connections_LocationStandard, rhs: Location_Nearby_Connections_LocationStandard) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Location_Nearby_Connections_LocationStandard.Format: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "E164_CALLING"),
    2: .same(proto: "ISO_3166_1_ALPHA_2"),
  ]
}

extension Location_Nearby_Connections_OsInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OsInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Location_Nearby_Connections_OsInfo, rhs: Location_Nearby_Connections_OsInfo) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Location_Nearby_Connections_OsInfo.OsType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_OS_TYPE"),
    1: .same(proto: "ANDROID"),
    2: .same(proto: "CHROME_OS"),
    3: .same(proto: "WINDOWS"),
    4: .same(proto: "APPLE"),
    100: .same(proto: "LINUX"),
  ]
}
