// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: wire_format.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Brought from: //depot/google3/location/nearby/sharing/proto/wire_format.proto
// At CL 317565061

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// File metadata. Does not include the actual bytes of the file.
/// NEXT_ID=6
struct Sharing_Nearby_FileMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The human readable name of this file (eg. 'Cookbook.pdf').
  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  /// The type of file (eg. 'IMAGE' from 'dog.jpg'). Specifying a type helps
  /// provide a richer experience on the receiving side.
  var type: Sharing_Nearby_FileMetadata.TypeEnum {
    get {return _type ?? .unknown}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  /// The FILE payload id that will be sent as a follow up containing the actual
  /// bytes of the file.
  var payloadID: Int64 {
    get {return _payloadID ?? 0}
    set {_payloadID = newValue}
  }
  /// Returns true if `payloadID` has been explicitly set.
  var hasPayloadID: Bool {return self._payloadID != nil}
  /// Clears the value of `payloadID`. Subsequent reads from it will return its default value.
  mutating func clearPayloadID() {self._payloadID = nil}

  /// The total size of the file.
  var size: Int64 {
    get {return _size ?? 0}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  mutating func clearSize() {self._size = nil}

  /// The mimeType of file (eg. 'image/jpeg' from 'dog.jpg'). Specifying a
  /// mimeType helps provide a richer experience on receiving side.
  var mimeType: String {
    get {return _mimeType ?? "application/octet-stream"}
    set {_mimeType = newValue}
  }
  /// Returns true if `mimeType` has been explicitly set.
  var hasMimeType: Bool {return self._mimeType != nil}
  /// Clears the value of `mimeType`. Subsequent reads from it will return its default value.
  mutating func clearMimeType() {self._mimeType = nil}

  /// A uuid for the attachment. Should be unique across all attachments.
  var id: Int64 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case image // = 1
    case video // = 2
    case app // = 3
    case audio // = 4

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .image
      case 2: self = .video
      case 3: self = .app
      case 4: self = .audio
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .image: return 1
      case .video: return 2
      case .app: return 3
      case .audio: return 4
      }
    }

  }

  init() {}

  fileprivate var _name: String? = nil
  fileprivate var _type: Sharing_Nearby_FileMetadata.TypeEnum? = nil
  fileprivate var _payloadID: Int64? = nil
  fileprivate var _size: Int64? = nil
  fileprivate var _mimeType: String? = nil
  fileprivate var _id: Int64? = nil
}

#if swift(>=4.2)

extension Sharing_Nearby_FileMetadata.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// NEXT_ID=5
struct Sharing_Nearby_TextMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The title of the text content.
  var textTitle: String {
    get {return _textTitle ?? String()}
    set {_textTitle = newValue}
  }
  /// Returns true if `textTitle` has been explicitly set.
  var hasTextTitle: Bool {return self._textTitle != nil}
  /// Clears the value of `textTitle`. Subsequent reads from it will return its default value.
  mutating func clearTextTitle() {self._textTitle = nil}

  /// The type of text (phone number, url, address, or plain text).
  var type: Sharing_Nearby_TextMetadata.TypeEnum {
    get {return _type ?? .unknown}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  /// The BYTE payload id that will be sent as a follow up containing the actual
  /// bytes of the text.
  var payloadID: Int64 {
    get {return _payloadID ?? 0}
    set {_payloadID = newValue}
  }
  /// Returns true if `payloadID` has been explicitly set.
  var hasPayloadID: Bool {return self._payloadID != nil}
  /// Clears the value of `payloadID`. Subsequent reads from it will return its default value.
  mutating func clearPayloadID() {self._payloadID = nil}

  /// The size of the text content.
  var size: Int64 {
    get {return _size ?? 0}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  mutating func clearSize() {self._size = nil}

  /// A uuid for the attachment. Should be unique across all attachments.
  var id: Int64 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case text // = 1

    /// Open with browsers.
    case url // = 2

    /// Open with map apps.
    case address // = 3

    /// Dial.
    case phoneNumber // = 4

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .text
      case 2: self = .url
      case 3: self = .address
      case 4: self = .phoneNumber
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .text: return 1
      case .url: return 2
      case .address: return 3
      case .phoneNumber: return 4
      }
    }

  }

  init() {}

  fileprivate var _textTitle: String? = nil
  fileprivate var _type: Sharing_Nearby_TextMetadata.TypeEnum? = nil
  fileprivate var _payloadID: Int64? = nil
  fileprivate var _size: Int64? = nil
  fileprivate var _id: Int64? = nil
}

#if swift(>=4.2)

extension Sharing_Nearby_TextMetadata.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// NEXT_ID=5
struct Sharing_Nearby_WifiCredentialsMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Wifi network name. This will be sent in introduction.
  var ssid: String {
    get {return _ssid ?? String()}
    set {_ssid = newValue}
  }
  /// Returns true if `ssid` has been explicitly set.
  var hasSsid: Bool {return self._ssid != nil}
  /// Clears the value of `ssid`. Subsequent reads from it will return its default value.
  mutating func clearSsid() {self._ssid = nil}

  /// The security type of network (OPEN, WPA_PSK, WEP).
  var securityType: Sharing_Nearby_WifiCredentialsMetadata.SecurityType {
    get {return _securityType ?? .unknownSecurityType}
    set {_securityType = newValue}
  }
  /// Returns true if `securityType` has been explicitly set.
  var hasSecurityType: Bool {return self._securityType != nil}
  /// Clears the value of `securityType`. Subsequent reads from it will return its default value.
  mutating func clearSecurityType() {self._securityType = nil}

  /// The BYTE payload id that will be sent as a follow up containing the
  /// password.
  var payloadID: Int64 {
    get {return _payloadID ?? 0}
    set {_payloadID = newValue}
  }
  /// Returns true if `payloadID` has been explicitly set.
  var hasPayloadID: Bool {return self._payloadID != nil}
  /// Clears the value of `payloadID`. Subsequent reads from it will return its default value.
  mutating func clearPayloadID() {self._payloadID = nil}

  /// A uuid for the attachment. Should be unique across all attachments.
  var id: Int64 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum SecurityType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknownSecurityType // = 0
    case `open` // = 1
    case wpaPsk // = 2
    case wep // = 3

    init() {
      self = .unknownSecurityType
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownSecurityType
      case 1: self = .open
      case 2: self = .wpaPsk
      case 3: self = .wep
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknownSecurityType: return 0
      case .open: return 1
      case .wpaPsk: return 2
      case .wep: return 3
      }
    }

  }

  init() {}

  fileprivate var _ssid: String? = nil
  fileprivate var _securityType: Sharing_Nearby_WifiCredentialsMetadata.SecurityType? = nil
  fileprivate var _payloadID: Int64? = nil
  fileprivate var _id: Int64? = nil
}

#if swift(>=4.2)

extension Sharing_Nearby_WifiCredentialsMetadata.SecurityType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// A frame used when sending messages over the wire.
/// NEXT_ID=3
struct Sharing_Nearby_Frame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: Sharing_Nearby_Frame.Version {
    get {return _version ?? .unknownVersion}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {self._version = nil}

  /// Right now there's only 1 version, but if there are more, exactly one of
  /// the following fields will be set.
  var v1: Sharing_Nearby_V1Frame {
    get {return _v1 ?? Sharing_Nearby_V1Frame()}
    set {_v1 = newValue}
  }
  /// Returns true if `v1` has been explicitly set.
  var hasV1: Bool {return self._v1 != nil}
  /// Clears the value of `v1`. Subsequent reads from it will return its default value.
  mutating func clearV1() {self._v1 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Version: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknownVersion // = 0
    case v1 // = 1

    init() {
      self = .unknownVersion
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownVersion
      case 1: self = .v1
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknownVersion: return 0
      case .v1: return 1
      }
    }

  }

  init() {}

  fileprivate var _version: Sharing_Nearby_Frame.Version? = nil
  fileprivate var _v1: Sharing_Nearby_V1Frame? = nil
}

#if swift(>=4.2)

extension Sharing_Nearby_Frame.Version: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// NEXT_ID=7
struct Sharing_Nearby_V1Frame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Sharing_Nearby_V1Frame.FrameType {
    get {return _type ?? .unknownFrameType}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  /// Exactly one of the following fields will be set.
  var introduction: Sharing_Nearby_IntroductionFrame {
    get {return _introduction ?? Sharing_Nearby_IntroductionFrame()}
    set {_introduction = newValue}
  }
  /// Returns true if `introduction` has been explicitly set.
  var hasIntroduction: Bool {return self._introduction != nil}
  /// Clears the value of `introduction`. Subsequent reads from it will return its default value.
  mutating func clearIntroduction() {self._introduction = nil}

  var connectionResponse: Sharing_Nearby_ConnectionResponseFrame {
    get {return _connectionResponse ?? Sharing_Nearby_ConnectionResponseFrame()}
    set {_connectionResponse = newValue}
  }
  /// Returns true if `connectionResponse` has been explicitly set.
  var hasConnectionResponse: Bool {return self._connectionResponse != nil}
  /// Clears the value of `connectionResponse`. Subsequent reads from it will return its default value.
  mutating func clearConnectionResponse() {self._connectionResponse = nil}

  var pairedKeyEncryption: Sharing_Nearby_PairedKeyEncryptionFrame {
    get {return _pairedKeyEncryption ?? Sharing_Nearby_PairedKeyEncryptionFrame()}
    set {_pairedKeyEncryption = newValue}
  }
  /// Returns true if `pairedKeyEncryption` has been explicitly set.
  var hasPairedKeyEncryption: Bool {return self._pairedKeyEncryption != nil}
  /// Clears the value of `pairedKeyEncryption`. Subsequent reads from it will return its default value.
  mutating func clearPairedKeyEncryption() {self._pairedKeyEncryption = nil}

  var pairedKeyResult: Sharing_Nearby_PairedKeyResultFrame {
    get {return _pairedKeyResult ?? Sharing_Nearby_PairedKeyResultFrame()}
    set {_pairedKeyResult = newValue}
  }
  /// Returns true if `pairedKeyResult` has been explicitly set.
  var hasPairedKeyResult: Bool {return self._pairedKeyResult != nil}
  /// Clears the value of `pairedKeyResult`. Subsequent reads from it will return its default value.
  mutating func clearPairedKeyResult() {self._pairedKeyResult = nil}

  var certificateInfo: Sharing_Nearby_CertificateInfoFrame {
    get {return _certificateInfo ?? Sharing_Nearby_CertificateInfoFrame()}
    set {_certificateInfo = newValue}
  }
  /// Returns true if `certificateInfo` has been explicitly set.
  var hasCertificateInfo: Bool {return self._certificateInfo != nil}
  /// Clears the value of `certificateInfo`. Subsequent reads from it will return its default value.
  mutating func clearCertificateInfo() {self._certificateInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum FrameType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknownFrameType // = 0
    case introduction // = 1
    case response // = 2
    case pairedKeyEncryption // = 3
    case pairedKeyResult // = 4
    case certificateInfo // = 5
    case cancel // = 6

    init() {
      self = .unknownFrameType
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownFrameType
      case 1: self = .introduction
      case 2: self = .response
      case 3: self = .pairedKeyEncryption
      case 4: self = .pairedKeyResult
      case 5: self = .certificateInfo
      case 6: self = .cancel
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknownFrameType: return 0
      case .introduction: return 1
      case .response: return 2
      case .pairedKeyEncryption: return 3
      case .pairedKeyResult: return 4
      case .certificateInfo: return 5
      case .cancel: return 6
      }
    }

  }

  init() {}

  fileprivate var _type: Sharing_Nearby_V1Frame.FrameType? = nil
  fileprivate var _introduction: Sharing_Nearby_IntroductionFrame? = nil
  fileprivate var _connectionResponse: Sharing_Nearby_ConnectionResponseFrame? = nil
  fileprivate var _pairedKeyEncryption: Sharing_Nearby_PairedKeyEncryptionFrame? = nil
  fileprivate var _pairedKeyResult: Sharing_Nearby_PairedKeyResultFrame? = nil
  fileprivate var _certificateInfo: Sharing_Nearby_CertificateInfoFrame? = nil
}

#if swift(>=4.2)

extension Sharing_Nearby_V1Frame.FrameType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// An introduction packet sent by the sending side. Contains a list of files
/// they'd like to share.
/// NEXT_ID=4
struct Sharing_Nearby_IntroductionFrame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fileMetadata: [Sharing_Nearby_FileMetadata] = []

  var textMetadata: [Sharing_Nearby_TextMetadata] = []

  /// The required app package to open the content. May be null.
  var requiredPackage: String {
    get {return _requiredPackage ?? String()}
    set {_requiredPackage = newValue}
  }
  /// Returns true if `requiredPackage` has been explicitly set.
  var hasRequiredPackage: Bool {return self._requiredPackage != nil}
  /// Clears the value of `requiredPackage`. Subsequent reads from it will return its default value.
  mutating func clearRequiredPackage() {self._requiredPackage = nil}

  var wifiCredentialsMetadata: [Sharing_Nearby_WifiCredentialsMetadata] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _requiredPackage: String? = nil
}

/// A response packet sent by the receiving side. Accepts or rejects the list of
/// files.
/// NEXT_ID=2
struct Sharing_Nearby_ConnectionResponseFrame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The receiving side's response.
  var status: Sharing_Nearby_ConnectionResponseFrame.Status {
    get {return _status ?? .unknown}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case accept // = 1
    case reject // = 2
    case notEnoughSpace // = 3
    case unsupportedAttachmentType // = 4
    case timedOut // = 5

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .accept
      case 2: self = .reject
      case 3: self = .notEnoughSpace
      case 4: self = .unsupportedAttachmentType
      case 5: self = .timedOut
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .accept: return 1
      case .reject: return 2
      case .notEnoughSpace: return 3
      case .unsupportedAttachmentType: return 4
      case .timedOut: return 5
      }
    }

  }

  init() {}

  fileprivate var _status: Sharing_Nearby_ConnectionResponseFrame.Status? = nil
}

#if swift(>=4.2)

extension Sharing_Nearby_ConnectionResponseFrame.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// A paired key encryption packet sent between devices, contains signed data.
/// NEXT_ID=3
struct Sharing_Nearby_PairedKeyEncryptionFrame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The encrypted data in byte array format.
  var signedData: Data {
    get {return _signedData ?? Data()}
    set {_signedData = newValue}
  }
  /// Returns true if `signedData` has been explicitly set.
  var hasSignedData: Bool {return self._signedData != nil}
  /// Clears the value of `signedData`. Subsequent reads from it will return its default value.
  mutating func clearSignedData() {self._signedData = nil}

  /// The hash of a certificate id.
  var secretIDHash: Data {
    get {return _secretIDHash ?? Data()}
    set {_secretIDHash = newValue}
  }
  /// Returns true if `secretIDHash` has been explicitly set.
  var hasSecretIDHash: Bool {return self._secretIDHash != nil}
  /// Clears the value of `secretIDHash`. Subsequent reads from it will return its default value.
  mutating func clearSecretIDHash() {self._secretIDHash = nil}

  /// An optional encrypted data in byte array format.
  var optionalSignedData: Data {
    get {return _optionalSignedData ?? Data()}
    set {_optionalSignedData = newValue}
  }
  /// Returns true if `optionalSignedData` has been explicitly set.
  var hasOptionalSignedData: Bool {return self._optionalSignedData != nil}
  /// Clears the value of `optionalSignedData`. Subsequent reads from it will return its default value.
  mutating func clearOptionalSignedData() {self._optionalSignedData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _signedData: Data? = nil
  fileprivate var _secretIDHash: Data? = nil
  fileprivate var _optionalSignedData: Data? = nil
}

/// A paired key verification result packet sent between devices.
/// NEXT_ID=2
struct Sharing_Nearby_PairedKeyResultFrame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The verification result.
  var status: Sharing_Nearby_PairedKeyResultFrame.Status {
    get {return _status ?? .unknown}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case success // = 1
    case fail // = 2
    case unable // = 3

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .success
      case 2: self = .fail
      case 3: self = .unable
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .success: return 1
      case .fail: return 2
      case .unable: return 3
      }
    }

  }

  init() {}

  fileprivate var _status: Sharing_Nearby_PairedKeyResultFrame.Status? = nil
}

#if swift(>=4.2)

extension Sharing_Nearby_PairedKeyResultFrame.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// A package containing certificate info to be shared to remote device offline.
/// NEXT_ID=2
struct Sharing_Nearby_CertificateInfoFrame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The public certificates to be shared with remote devices.
  var publicCertificate: [Sharing_Nearby_PublicCertificate] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A public certificate from the local device.
/// NEXT_ID=8
struct Sharing_Nearby_PublicCertificate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique id of the public certificate.
  var secretID: Data {
    get {return _secretID ?? Data()}
    set {_secretID = newValue}
  }
  /// Returns true if `secretID` has been explicitly set.
  var hasSecretID: Bool {return self._secretID != nil}
  /// Clears the value of `secretID`. Subsequent reads from it will return its default value.
  mutating func clearSecretID() {self._secretID = nil}

  /// A bytes representation of a Secret Key owned by contact, to decrypt the
  /// metadata_key stored within the advertisement.
  var authenticityKey: Data {
    get {return _authenticityKey ?? Data()}
    set {_authenticityKey = newValue}
  }
  /// Returns true if `authenticityKey` has been explicitly set.
  var hasAuthenticityKey: Bool {return self._authenticityKey != nil}
  /// Clears the value of `authenticityKey`. Subsequent reads from it will return its default value.
  mutating func clearAuthenticityKey() {self._authenticityKey = nil}

  /// A bytes representation a public key of X509Certificate, owned by contact,
  /// to decrypt encrypted UKEY2 (from Nearby Connections API) as a hand shake in
  /// contact verification phase.
  var publicKey: Data {
    get {return _publicKey ?? Data()}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  mutating func clearPublicKey() {self._publicKey = nil}

  /// The time in millis from epoch when this certificate becomes effective.
  var startTime: Int64 {
    get {return _startTime ?? 0}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  mutating func clearStartTime() {self._startTime = nil}

  /// The time in millis from epoch when this certificate expires.
  var endTime: Int64 {
    get {return _endTime ?? 0}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  mutating func clearEndTime() {self._endTime = nil}

  /// The encrypted metadata in bytes, contains personal information of the
  /// device/user who created this certificate. Needs to be decrypted into bytes,
  /// and converted back to EncryptedMetadata object to access fields.
  var encryptedMetadataBytes: Data {
    get {return _encryptedMetadataBytes ?? Data()}
    set {_encryptedMetadataBytes = newValue}
  }
  /// Returns true if `encryptedMetadataBytes` has been explicitly set.
  var hasEncryptedMetadataBytes: Bool {return self._encryptedMetadataBytes != nil}
  /// Clears the value of `encryptedMetadataBytes`. Subsequent reads from it will return its default value.
  mutating func clearEncryptedMetadataBytes() {self._encryptedMetadataBytes = nil}

  /// The tag for verifying metadata_encryption_key.
  var metadataEncryptionKeyTag: Data {
    get {return _metadataEncryptionKeyTag ?? Data()}
    set {_metadataEncryptionKeyTag = newValue}
  }
  /// Returns true if `metadataEncryptionKeyTag` has been explicitly set.
  var hasMetadataEncryptionKeyTag: Bool {return self._metadataEncryptionKeyTag != nil}
  /// Clears the value of `metadataEncryptionKeyTag`. Subsequent reads from it will return its default value.
  mutating func clearMetadataEncryptionKeyTag() {self._metadataEncryptionKeyTag = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _secretID: Data? = nil
  fileprivate var _authenticityKey: Data? = nil
  fileprivate var _publicKey: Data? = nil
  fileprivate var _startTime: Int64? = nil
  fileprivate var _endTime: Int64? = nil
  fileprivate var _encryptedMetadataBytes: Data? = nil
  fileprivate var _metadataEncryptionKeyTag: Data? = nil
}

/// NEXT_ID=3
struct Sharing_Nearby_WifiCredentials {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Wi-Fi password.
  var password: String {
    get {return _password ?? String()}
    set {_password = newValue}
  }
  /// Returns true if `password` has been explicitly set.
  var hasPassword: Bool {return self._password != nil}
  /// Clears the value of `password`. Subsequent reads from it will return its default value.
  mutating func clearPassword() {self._password = nil}

  /// True if the network is a hidden network that is not broadcasting its SSID.
  /// Default is false.
  var hiddenSsid: Bool {
    get {return _hiddenSsid ?? false}
    set {_hiddenSsid = newValue}
  }
  /// Returns true if `hiddenSsid` has been explicitly set.
  var hasHiddenSsid: Bool {return self._hiddenSsid != nil}
  /// Clears the value of `hiddenSsid`. Subsequent reads from it will return its default value.
  mutating func clearHiddenSsid() {self._hiddenSsid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _password: String? = nil
  fileprivate var _hiddenSsid: Bool? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Sharing_Nearby_FileMetadata: @unchecked Sendable {}
extension Sharing_Nearby_FileMetadata.TypeEnum: @unchecked Sendable {}
extension Sharing_Nearby_TextMetadata: @unchecked Sendable {}
extension Sharing_Nearby_TextMetadata.TypeEnum: @unchecked Sendable {}
extension Sharing_Nearby_WifiCredentialsMetadata: @unchecked Sendable {}
extension Sharing_Nearby_WifiCredentialsMetadata.SecurityType: @unchecked Sendable {}
extension Sharing_Nearby_Frame: @unchecked Sendable {}
extension Sharing_Nearby_Frame.Version: @unchecked Sendable {}
extension Sharing_Nearby_V1Frame: @unchecked Sendable {}
extension Sharing_Nearby_V1Frame.FrameType: @unchecked Sendable {}
extension Sharing_Nearby_IntroductionFrame: @unchecked Sendable {}
extension Sharing_Nearby_ConnectionResponseFrame: @unchecked Sendable {}
extension Sharing_Nearby_ConnectionResponseFrame.Status: @unchecked Sendable {}
extension Sharing_Nearby_PairedKeyEncryptionFrame: @unchecked Sendable {}
extension Sharing_Nearby_PairedKeyResultFrame: @unchecked Sendable {}
extension Sharing_Nearby_PairedKeyResultFrame.Status: @unchecked Sendable {}
extension Sharing_Nearby_CertificateInfoFrame: @unchecked Sendable {}
extension Sharing_Nearby_PublicCertificate: @unchecked Sendable {}
extension Sharing_Nearby_WifiCredentials: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "sharing.nearby"

extension Sharing_Nearby_FileMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FileMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "type"),
    3: .standard(proto: "payload_id"),
    4: .same(proto: "size"),
    5: .standard(proto: "mime_type"),
    6: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self._payloadID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self._size) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._mimeType) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self._id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._payloadID {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._size {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._mimeType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._id {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sharing_Nearby_FileMetadata, rhs: Sharing_Nearby_FileMetadata) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._type != rhs._type {return false}
    if lhs._payloadID != rhs._payloadID {return false}
    if lhs._size != rhs._size {return false}
    if lhs._mimeType != rhs._mimeType {return false}
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sharing_Nearby_FileMetadata.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "IMAGE"),
    2: .same(proto: "VIDEO"),
    3: .same(proto: "APP"),
    4: .same(proto: "AUDIO"),
  ]
}

extension Sharing_Nearby_TextMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TextMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "text_title"),
    3: .same(proto: "type"),
    4: .standard(proto: "payload_id"),
    5: .same(proto: "size"),
    6: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self._textTitle) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self._payloadID) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self._size) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self._id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._textTitle {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._payloadID {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._size {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._id {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sharing_Nearby_TextMetadata, rhs: Sharing_Nearby_TextMetadata) -> Bool {
    if lhs._textTitle != rhs._textTitle {return false}
    if lhs._type != rhs._type {return false}
    if lhs._payloadID != rhs._payloadID {return false}
    if lhs._size != rhs._size {return false}
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sharing_Nearby_TextMetadata.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "TEXT"),
    2: .same(proto: "URL"),
    3: .same(proto: "ADDRESS"),
    4: .same(proto: "PHONE_NUMBER"),
  ]
}

extension Sharing_Nearby_WifiCredentialsMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WifiCredentialsMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "ssid"),
    3: .standard(proto: "security_type"),
    4: .standard(proto: "payload_id"),
    5: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self._ssid) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._securityType) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self._payloadID) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self._id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ssid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._securityType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._payloadID {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._id {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sharing_Nearby_WifiCredentialsMetadata, rhs: Sharing_Nearby_WifiCredentialsMetadata) -> Bool {
    if lhs._ssid != rhs._ssid {return false}
    if lhs._securityType != rhs._securityType {return false}
    if lhs._payloadID != rhs._payloadID {return false}
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sharing_Nearby_WifiCredentialsMetadata.SecurityType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_SECURITY_TYPE"),
    1: .same(proto: "OPEN"),
    2: .same(proto: "WPA_PSK"),
    3: .same(proto: "WEP"),
  ]
}

extension Sharing_Nearby_Frame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Frame"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "v1"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._version) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._v1) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._version {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._v1 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sharing_Nearby_Frame, rhs: Sharing_Nearby_Frame) -> Bool {
    if lhs._version != rhs._version {return false}
    if lhs._v1 != rhs._v1 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sharing_Nearby_Frame.Version: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_VERSION"),
    1: .same(proto: "V1"),
  ]
}

extension Sharing_Nearby_V1Frame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".V1Frame"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "introduction"),
    3: .standard(proto: "connection_response"),
    4: .standard(proto: "paired_key_encryption"),
    5: .standard(proto: "paired_key_result"),
    6: .standard(proto: "certificate_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._introduction) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._connectionResponse) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._pairedKeyEncryption) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._pairedKeyResult) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._certificateInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._introduction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._connectionResponse {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._pairedKeyEncryption {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._pairedKeyResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._certificateInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sharing_Nearby_V1Frame, rhs: Sharing_Nearby_V1Frame) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._introduction != rhs._introduction {return false}
    if lhs._connectionResponse != rhs._connectionResponse {return false}
    if lhs._pairedKeyEncryption != rhs._pairedKeyEncryption {return false}
    if lhs._pairedKeyResult != rhs._pairedKeyResult {return false}
    if lhs._certificateInfo != rhs._certificateInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sharing_Nearby_V1Frame.FrameType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_FRAME_TYPE"),
    1: .same(proto: "INTRODUCTION"),
    2: .same(proto: "RESPONSE"),
    3: .same(proto: "PAIRED_KEY_ENCRYPTION"),
    4: .same(proto: "PAIRED_KEY_RESULT"),
    5: .same(proto: "CERTIFICATE_INFO"),
    6: .same(proto: "CANCEL"),
  ]
}

extension Sharing_Nearby_IntroductionFrame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IntroductionFrame"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_metadata"),
    2: .standard(proto: "text_metadata"),
    3: .standard(proto: "required_package"),
    4: .standard(proto: "wifi_credentials_metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.fileMetadata) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.textMetadata) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._requiredPackage) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.wifiCredentialsMetadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.fileMetadata.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fileMetadata, fieldNumber: 1)
    }
    if !self.textMetadata.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.textMetadata, fieldNumber: 2)
    }
    try { if let v = self._requiredPackage {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    if !self.wifiCredentialsMetadata.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.wifiCredentialsMetadata, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sharing_Nearby_IntroductionFrame, rhs: Sharing_Nearby_IntroductionFrame) -> Bool {
    if lhs.fileMetadata != rhs.fileMetadata {return false}
    if lhs.textMetadata != rhs.textMetadata {return false}
    if lhs._requiredPackage != rhs._requiredPackage {return false}
    if lhs.wifiCredentialsMetadata != rhs.wifiCredentialsMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sharing_Nearby_ConnectionResponseFrame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectionResponseFrame"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sharing_Nearby_ConnectionResponseFrame, rhs: Sharing_Nearby_ConnectionResponseFrame) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sharing_Nearby_ConnectionResponseFrame.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "ACCEPT"),
    2: .same(proto: "REJECT"),
    3: .same(proto: "NOT_ENOUGH_SPACE"),
    4: .same(proto: "UNSUPPORTED_ATTACHMENT_TYPE"),
    5: .same(proto: "TIMED_OUT"),
  ]
}

extension Sharing_Nearby_PairedKeyEncryptionFrame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PairedKeyEncryptionFrame"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "signed_data"),
    2: .standard(proto: "secret_id_hash"),
    3: .standard(proto: "optional_signed_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._signedData) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._secretIDHash) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._optionalSignedData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._signedData {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._secretIDHash {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._optionalSignedData {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sharing_Nearby_PairedKeyEncryptionFrame, rhs: Sharing_Nearby_PairedKeyEncryptionFrame) -> Bool {
    if lhs._signedData != rhs._signedData {return false}
    if lhs._secretIDHash != rhs._secretIDHash {return false}
    if lhs._optionalSignedData != rhs._optionalSignedData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sharing_Nearby_PairedKeyResultFrame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PairedKeyResultFrame"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sharing_Nearby_PairedKeyResultFrame, rhs: Sharing_Nearby_PairedKeyResultFrame) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sharing_Nearby_PairedKeyResultFrame.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "SUCCESS"),
    2: .same(proto: "FAIL"),
    3: .same(proto: "UNABLE"),
  ]
}

extension Sharing_Nearby_CertificateInfoFrame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CertificateInfoFrame"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_certificate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.publicCertificate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicCertificate.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.publicCertificate, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sharing_Nearby_CertificateInfoFrame, rhs: Sharing_Nearby_CertificateInfoFrame) -> Bool {
    if lhs.publicCertificate != rhs.publicCertificate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sharing_Nearby_PublicCertificate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PublicCertificate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "secret_id"),
    2: .standard(proto: "authenticity_key"),
    3: .standard(proto: "public_key"),
    4: .standard(proto: "start_time"),
    5: .standard(proto: "end_time"),
    6: .standard(proto: "encrypted_metadata_bytes"),
    7: .standard(proto: "metadata_encryption_key_tag"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._secretID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._authenticityKey) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._publicKey) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self._startTime) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self._endTime) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self._encryptedMetadataBytes) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self._metadataEncryptionKeyTag) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._secretID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._authenticityKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._publicKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._startTime {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._endTime {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._encryptedMetadataBytes {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._metadataEncryptionKeyTag {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sharing_Nearby_PublicCertificate, rhs: Sharing_Nearby_PublicCertificate) -> Bool {
    if lhs._secretID != rhs._secretID {return false}
    if lhs._authenticityKey != rhs._authenticityKey {return false}
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs._encryptedMetadataBytes != rhs._encryptedMetadataBytes {return false}
    if lhs._metadataEncryptionKeyTag != rhs._metadataEncryptionKeyTag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sharing_Nearby_WifiCredentials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WifiCredentials"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "password"),
    2: .standard(proto: "hidden_ssid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._password) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._hiddenSsid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._password {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._hiddenSsid {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sharing_Nearby_WifiCredentials, rhs: Sharing_Nearby_WifiCredentials) -> Bool {
    if lhs._password != rhs._password {return false}
    if lhs._hiddenSsid != rhs._hiddenSsid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
