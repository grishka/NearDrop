// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: securegcm.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// This enum is used by iOS devices as values for device_display_diagonal_mils
/// in GcmDeviceInfo. There is no good way to calculate it on those devices.
enum Securegcm_AppleDeviceDiagonalMils: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// This is the mils diagonal on an iPhone 5.
  case applePhone // = 4000

  /// This is the mils diagonal on an iPad mini.
  case applePad // = 7900

  init() {
    self = .applePhone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 4000: self = .applePhone
    case 7900: self = .applePad
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .applePhone: return 4000
    case .applePad: return 7900
    }
  }

}

#if swift(>=4.2)

extension Securegcm_AppleDeviceDiagonalMils: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// This should be kept in sync with DeviceType in:
/// java/com/google/security/cryptauth/backend/services/common/common_enums.proto
enum Securegcm_DeviceType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case android // = 1
  case chrome // = 2
  case ios // = 3
  case browser // = 4
  case osx // = 5

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .android
    case 2: self = .chrome
    case 3: self = .ios
    case 4: self = .browser
    case 5: self = .osx
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .android: return 1
    case .chrome: return 2
    case .ios: return 3
    case .browser: return 4
    case .osx: return 5
    }
  }

}

#if swift(>=4.2)

extension Securegcm_DeviceType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// MultiDevice features which may be supported and enabled on a device. See
enum Securegcm_SoftwareFeature: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownFeature // = 0
  case betterTogetherHost // = 1
  case betterTogetherClient // = 2
  case easyUnlockHost // = 3
  case easyUnlockClient // = 4
  case magicTetherHost // = 5
  case magicTetherClient // = 6
  case smsConnectHost // = 7
  case smsConnectClient // = 8

  init() {
    self = .unknownFeature
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownFeature
    case 1: self = .betterTogetherHost
    case 2: self = .betterTogetherClient
    case 3: self = .easyUnlockHost
    case 4: self = .easyUnlockClient
    case 5: self = .magicTetherHost
    case 6: self = .magicTetherClient
    case 7: self = .smsConnectHost
    case 8: self = .smsConnectClient
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownFeature: return 0
    case .betterTogetherHost: return 1
    case .betterTogetherClient: return 2
    case .easyUnlockHost: return 3
    case .easyUnlockClient: return 4
    case .magicTetherHost: return 5
    case .magicTetherClient: return 6
    case .smsConnectHost: return 7
    case .smsConnectClient: return 8
    }
  }

}

#if swift(>=4.2)

extension Securegcm_SoftwareFeature: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// A list of "reasons" that can be provided for calling server-side APIs.
/// This is particularly important for calls that can be triggered by different
/// kinds of events. Please try to keep reasons as generic as possible, so that
/// codes can be re-used by various callers in a sensible fashion.
enum Securegcm_InvocationReason: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case reasonUnknown // = 0

  /// First run of the software package invoking this call
  case reasonInitialization // = 1

  /// Ordinary periodic actions (e.g. monthly master key rotation)
  case reasonPeriodic // = 2

  /// Slow-cycle periodic action (e.g. yearly keypair rotation???)
  case reasonSlowPeriodic // = 3

  /// Fast-cycle periodic action (e.g. daily sync for Smart Lock users)
  case reasonFastPeriodic // = 4

  /// Expired state (e.g. expired credentials, or cached entries) was detected
  case reasonExpiration // = 5

  /// An unexpected protocol failure occurred (so attempting to repair state)
  case reasonFailureRecovery // = 6

  /// A new account has been added to the device
  case reasonNewAccount // = 7

  /// An existing account on the device has been changed
  case reasonChangedAccount // = 8

  /// The user toggled the state of a feature (e.g. Smart Lock enabled via BT)
  case reasonFeatureToggled // = 9

  /// A "push" from the server caused this action (e.g. a sync tickle)
  case reasonServerInitiated // = 10

  /// A local address change triggered this (e.g. GCM registration id changed)
  case reasonAddressChange // = 11

  /// A software update has triggered this
  case reasonSoftwareUpdate // = 12

  /// A manual action by the user triggered this (e.g. commands sent via adb)
  case reasonManual // = 13

  /// A custom key has been invalidated on the device (e.g. screen lock is
  /// disabled).
  case reasonCustomKeyInvalidation // = 14

  /// Periodic action triggered by auth_proximity
  case reasonProximityPeriodic // = 15

  init() {
    self = .reasonUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .reasonUnknown
    case 1: self = .reasonInitialization
    case 2: self = .reasonPeriodic
    case 3: self = .reasonSlowPeriodic
    case 4: self = .reasonFastPeriodic
    case 5: self = .reasonExpiration
    case 6: self = .reasonFailureRecovery
    case 7: self = .reasonNewAccount
    case 8: self = .reasonChangedAccount
    case 9: self = .reasonFeatureToggled
    case 10: self = .reasonServerInitiated
    case 11: self = .reasonAddressChange
    case 12: self = .reasonSoftwareUpdate
    case 13: self = .reasonManual
    case 14: self = .reasonCustomKeyInvalidation
    case 15: self = .reasonProximityPeriodic
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .reasonUnknown: return 0
    case .reasonInitialization: return 1
    case .reasonPeriodic: return 2
    case .reasonSlowPeriodic: return 3
    case .reasonFastPeriodic: return 4
    case .reasonExpiration: return 5
    case .reasonFailureRecovery: return 6
    case .reasonNewAccount: return 7
    case .reasonChangedAccount: return 8
    case .reasonFeatureToggled: return 9
    case .reasonServerInitiated: return 10
    case .reasonAddressChange: return 11
    case .reasonSoftwareUpdate: return 12
    case .reasonManual: return 13
    case .reasonCustomKeyInvalidation: return 14
    case .reasonProximityPeriodic: return 15
    }
  }

}

#if swift(>=4.2)

extension Securegcm_InvocationReason: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum Securegcm_Type: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case enrollment // = 0
  case tickle // = 1
  case txRequest // = 2
  case txReply // = 3
  case txSyncRequest // = 4
  case txSyncResponse // = 5
  case txPing // = 6
  case deviceInfoUpdate // = 7
  case txCancelRequest // = 8

  /// DEPRECATED (can be re-used after Aug 2015)
  case proximityauthPairing // = 10

  /// The kind of identity assertion generated by a "GCM V1" device (i.e.,
  /// an Android phone that has registered with us a public and a symmetric
  /// key)
  case gcmv1IdentityAssertion // = 11

  /// Device-to-device communications are protected by an unauthenticated
  /// Diffie-Hellman exchange. The InitiatorHello message is simply the
  /// initiator's public DH key, and is not encoded as a SecureMessage, so
  /// it doesn't have a tag.
  /// The ResponderHello message (which is sent by the responder
  /// to the initiator), on the other hand, carries a payload that is protected
  /// by the derived shared key. It also contains the responder's
  /// public DH key. ResponderHelloAndPayload messages have the
  /// DEVICE_TO_DEVICE_RESPONDER_HELLO tag.
  case deviceToDeviceResponderHelloPayload // = 12

  /// Device-to-device communications are protected by an unauthenticated
  /// Diffie-Hellman exchange. Once the initiator and responder
  /// agree on a shared key (through Diffie-Hellman), they will use messages
  /// tagged with DEVICE_TO_DEVICE_MESSAGE to exchange data.
  case deviceToDeviceMessage // = 13

  /// Notification to let a device know it should contact a nearby device.
  case deviceProximityCallback // = 14

  /// Device-to-device communications are protected by an unauthenticated
  /// Diffie-Hellman exchange. During device-to-device authentication, the first
  /// message from initiator (the challenge) is signed and put into the payload
  /// of the message sent back to the initiator.
  case unlockKeySignedChallenge // = 15

  /// Specialty (corp only) features
  case loginNotification // = 101

  init() {
    self = .enrollment
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .enrollment
    case 1: self = .tickle
    case 2: self = .txRequest
    case 3: self = .txReply
    case 4: self = .txSyncRequest
    case 5: self = .txSyncResponse
    case 6: self = .txPing
    case 7: self = .deviceInfoUpdate
    case 8: self = .txCancelRequest
    case 10: self = .proximityauthPairing
    case 11: self = .gcmv1IdentityAssertion
    case 12: self = .deviceToDeviceResponderHelloPayload
    case 13: self = .deviceToDeviceMessage
    case 14: self = .deviceProximityCallback
    case 15: self = .unlockKeySignedChallenge
    case 101: self = .loginNotification
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .enrollment: return 0
    case .tickle: return 1
    case .txRequest: return 2
    case .txReply: return 3
    case .txSyncRequest: return 4
    case .txSyncResponse: return 5
    case .txPing: return 6
    case .deviceInfoUpdate: return 7
    case .txCancelRequest: return 8
    case .proximityauthPairing: return 10
    case .gcmv1IdentityAssertion: return 11
    case .deviceToDeviceResponderHelloPayload: return 12
    case .deviceToDeviceMessage: return 13
    case .deviceProximityCallback: return 14
    case .unlockKeySignedChallenge: return 15
    case .loginNotification: return 101
    }
  }

}

#if swift(>=4.2)

extension Securegcm_Type: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// Message used only during enrollment
/// Field numbers should be kept in sync with DeviceInfo in:
///   java/com/google/security/cryptauth/backend/services/common/common.proto
struct Securegcm_GcmDeviceInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This field's name does not match the one in DeviceInfo for legacy reasons.
  /// Consider using long_device_id and device_type instead when enrolling
  /// non-android devices.
  var androidDeviceID: UInt64 {
    get {return _storage._androidDeviceID ?? 0}
    set {_uniqueStorage()._androidDeviceID = newValue}
  }
  /// Returns true if `androidDeviceID` has been explicitly set.
  var hasAndroidDeviceID: Bool {return _storage._androidDeviceID != nil}
  /// Clears the value of `androidDeviceID`. Subsequent reads from it will return its default value.
  mutating func clearAndroidDeviceID() {_uniqueStorage()._androidDeviceID = nil}

  /// Used for device_address of DeviceInfo field 2, but for GCM capable devices.
  var gcmRegistrationID: Data {
    get {return _storage._gcmRegistrationID ?? Data()}
    set {_uniqueStorage()._gcmRegistrationID = newValue}
  }
  /// Returns true if `gcmRegistrationID` has been explicitly set.
  var hasGcmRegistrationID: Bool {return _storage._gcmRegistrationID != nil}
  /// Clears the value of `gcmRegistrationID`. Subsequent reads from it will return its default value.
  mutating func clearGcmRegistrationID() {_uniqueStorage()._gcmRegistrationID = nil}

  /// Used for device_address of DeviceInfo field 2, but for iOS devices.
  var apnRegistrationID: Data {
    get {return _storage._apnRegistrationID ?? Data()}
    set {_uniqueStorage()._apnRegistrationID = newValue}
  }
  /// Returns true if `apnRegistrationID` has been explicitly set.
  var hasApnRegistrationID: Bool {return _storage._apnRegistrationID != nil}
  /// Clears the value of `apnRegistrationID`. Subsequent reads from it will return its default value.
  mutating func clearApnRegistrationID() {_uniqueStorage()._apnRegistrationID = nil}

  /// Does the user have notifications enabled for the given device address.
  var notificationEnabled: Bool {
    get {return _storage._notificationEnabled ?? true}
    set {_uniqueStorage()._notificationEnabled = newValue}
  }
  /// Returns true if `notificationEnabled` has been explicitly set.
  var hasNotificationEnabled: Bool {return _storage._notificationEnabled != nil}
  /// Clears the value of `notificationEnabled`. Subsequent reads from it will return its default value.
  mutating func clearNotificationEnabled() {_uniqueStorage()._notificationEnabled = nil}

  /// Used for device_address of DeviceInfo field 2, a Bluetooth Mac address for
  /// the device (e.g., to be used with EasyUnlock)
  var bluetoothMacAddress: String {
    get {return _storage._bluetoothMacAddress ?? String()}
    set {_uniqueStorage()._bluetoothMacAddress = newValue}
  }
  /// Returns true if `bluetoothMacAddress` has been explicitly set.
  var hasBluetoothMacAddress: Bool {return _storage._bluetoothMacAddress != nil}
  /// Clears the value of `bluetoothMacAddress`. Subsequent reads from it will return its default value.
  mutating func clearBluetoothMacAddress() {_uniqueStorage()._bluetoothMacAddress = nil}

  /// SHA-256 hash of the device master key (from the key exchange).
  /// Differs from DeviceInfo field 3, which contains the actual master key.
  var deviceMasterKeyHash: Data {
    get {return _storage._deviceMasterKeyHash ?? Data()}
    set {_uniqueStorage()._deviceMasterKeyHash = newValue}
  }
  /// Returns true if `deviceMasterKeyHash` has been explicitly set.
  var hasDeviceMasterKeyHash: Bool {return _storage._deviceMasterKeyHash != nil}
  /// Clears the value of `deviceMasterKeyHash`. Subsequent reads from it will return its default value.
  mutating func clearDeviceMasterKeyHash() {_uniqueStorage()._deviceMasterKeyHash = nil}

  /// A SecureMessage.EcP256PublicKey
  var userPublicKey: Data {
    get {return _storage._userPublicKey ?? Data()}
    set {_uniqueStorage()._userPublicKey = newValue}
  }
  /// Returns true if `userPublicKey` has been explicitly set.
  var hasUserPublicKey: Bool {return _storage._userPublicKey != nil}
  /// Clears the value of `userPublicKey`. Subsequent reads from it will return its default value.
  mutating func clearUserPublicKey() {_uniqueStorage()._userPublicKey = nil}

  /// device's model name
  /// (e.g., an android.os.Build.MODEL or UIDevice.model)
  var deviceModel: String {
    get {return _storage._deviceModel ?? String()}
    set {_uniqueStorage()._deviceModel = newValue}
  }
  /// Returns true if `deviceModel` has been explicitly set.
  var hasDeviceModel: Bool {return _storage._deviceModel != nil}
  /// Clears the value of `deviceModel`. Subsequent reads from it will return its default value.
  mutating func clearDeviceModel() {_uniqueStorage()._deviceModel = nil}

  /// device's locale
  var locale: String {
    get {return _storage._locale ?? String()}
    set {_uniqueStorage()._locale = newValue}
  }
  /// Returns true if `locale` has been explicitly set.
  var hasLocale: Bool {return _storage._locale != nil}
  /// Clears the value of `locale`. Subsequent reads from it will return its default value.
  mutating func clearLocale() {_uniqueStorage()._locale = nil}

  /// The handle for user_public_key (and implicitly, a master key)
  var keyHandle: Data {
    get {return _storage._keyHandle ?? Data()}
    set {_uniqueStorage()._keyHandle = newValue}
  }
  /// Returns true if `keyHandle` has been explicitly set.
  var hasKeyHandle: Bool {return _storage._keyHandle != nil}
  /// Clears the value of `keyHandle`. Subsequent reads from it will return its default value.
  mutating func clearKeyHandle() {_uniqueStorage()._keyHandle = nil}

  /// The initial counter value for the device, sent by the device
  var counter: Int64 {
    get {return _storage._counter ?? 0}
    set {_uniqueStorage()._counter = newValue}
  }
  /// Returns true if `counter` has been explicitly set.
  var hasCounter: Bool {return _storage._counter != nil}
  /// Clears the value of `counter`. Subsequent reads from it will return its default value.
  mutating func clearCounter() {_uniqueStorage()._counter = nil}

  /// The Operating System version on the device
  /// (e.g., an android.os.Build.DISPLAY or UIDevice.systemVersion)
  var deviceOsVersion: String {
    get {return _storage._deviceOsVersion ?? String()}
    set {_uniqueStorage()._deviceOsVersion = newValue}
  }
  /// Returns true if `deviceOsVersion` has been explicitly set.
  var hasDeviceOsVersion: Bool {return _storage._deviceOsVersion != nil}
  /// Clears the value of `deviceOsVersion`. Subsequent reads from it will return its default value.
  mutating func clearDeviceOsVersion() {_uniqueStorage()._deviceOsVersion = nil}

  /// The Operating System version number on the device
  /// (e.g., an android.os.Build.VERSION.SDK_INT)
  var deviceOsVersionCode: Int64 {
    get {return _storage._deviceOsVersionCode ?? 0}
    set {_uniqueStorage()._deviceOsVersionCode = newValue}
  }
  /// Returns true if `deviceOsVersionCode` has been explicitly set.
  var hasDeviceOsVersionCode: Bool {return _storage._deviceOsVersionCode != nil}
  /// Clears the value of `deviceOsVersionCode`. Subsequent reads from it will return its default value.
  mutating func clearDeviceOsVersionCode() {_uniqueStorage()._deviceOsVersionCode = nil}

  /// The Operating System release on the device
  /// (e.g., an android.os.Build.VERSION.RELEASE)
  var deviceOsRelease: String {
    get {return _storage._deviceOsRelease ?? String()}
    set {_uniqueStorage()._deviceOsRelease = newValue}
  }
  /// Returns true if `deviceOsRelease` has been explicitly set.
  var hasDeviceOsRelease: Bool {return _storage._deviceOsRelease != nil}
  /// Clears the value of `deviceOsRelease`. Subsequent reads from it will return its default value.
  mutating func clearDeviceOsRelease() {_uniqueStorage()._deviceOsRelease = nil}

  /// The Operating System codename on the device
  /// (e.g., an android.os.Build.VERSION.CODENAME or UIDevice.systemName)
  var deviceOsCodename: String {
    get {return _storage._deviceOsCodename ?? String()}
    set {_uniqueStorage()._deviceOsCodename = newValue}
  }
  /// Returns true if `deviceOsCodename` has been explicitly set.
  var hasDeviceOsCodename: Bool {return _storage._deviceOsCodename != nil}
  /// Clears the value of `deviceOsCodename`. Subsequent reads from it will return its default value.
  mutating func clearDeviceOsCodename() {_uniqueStorage()._deviceOsCodename = nil}

  /// The software version running on the device
  /// (e.g., Authenticator app version string)
  var deviceSoftwareVersion: String {
    get {return _storage._deviceSoftwareVersion ?? String()}
    set {_uniqueStorage()._deviceSoftwareVersion = newValue}
  }
  /// Returns true if `deviceSoftwareVersion` has been explicitly set.
  var hasDeviceSoftwareVersion: Bool {return _storage._deviceSoftwareVersion != nil}
  /// Clears the value of `deviceSoftwareVersion`. Subsequent reads from it will return its default value.
  mutating func clearDeviceSoftwareVersion() {_uniqueStorage()._deviceSoftwareVersion = nil}

  /// The software version number running on the device
  /// (e.g., Authenticator app version code)
  var deviceSoftwareVersionCode: Int64 {
    get {return _storage._deviceSoftwareVersionCode ?? 0}
    set {_uniqueStorage()._deviceSoftwareVersionCode = newValue}
  }
  /// Returns true if `deviceSoftwareVersionCode` has been explicitly set.
  var hasDeviceSoftwareVersionCode: Bool {return _storage._deviceSoftwareVersionCode != nil}
  /// Clears the value of `deviceSoftwareVersionCode`. Subsequent reads from it will return its default value.
  mutating func clearDeviceSoftwareVersionCode() {_uniqueStorage()._deviceSoftwareVersionCode = nil}

  /// Software package information if applicable
  /// (e.g., com.google.android.apps.authenticator2)
  var deviceSoftwarePackage: String {
    get {return _storage._deviceSoftwarePackage ?? String()}
    set {_uniqueStorage()._deviceSoftwarePackage = newValue}
  }
  /// Returns true if `deviceSoftwarePackage` has been explicitly set.
  var hasDeviceSoftwarePackage: Bool {return _storage._deviceSoftwarePackage != nil}
  /// Clears the value of `deviceSoftwarePackage`. Subsequent reads from it will return its default value.
  mutating func clearDeviceSoftwarePackage() {_uniqueStorage()._deviceSoftwarePackage = nil}

  /// Size of the display in thousandths of an inch (e.g., 7000 mils = 7 in)
  var deviceDisplayDiagonalMils: Int32 {
    get {return _storage._deviceDisplayDiagonalMils ?? 0}
    set {_uniqueStorage()._deviceDisplayDiagonalMils = newValue}
  }
  /// Returns true if `deviceDisplayDiagonalMils` has been explicitly set.
  var hasDeviceDisplayDiagonalMils: Bool {return _storage._deviceDisplayDiagonalMils != nil}
  /// Clears the value of `deviceDisplayDiagonalMils`. Subsequent reads from it will return its default value.
  mutating func clearDeviceDisplayDiagonalMils() {_uniqueStorage()._deviceDisplayDiagonalMils = nil}

  /// For Authzen capable devices, their Authzen protocol version
  var deviceAuthzenVersion: Int32 {
    get {return _storage._deviceAuthzenVersion ?? 0}
    set {_uniqueStorage()._deviceAuthzenVersion = newValue}
  }
  /// Returns true if `deviceAuthzenVersion` has been explicitly set.
  var hasDeviceAuthzenVersion: Bool {return _storage._deviceAuthzenVersion != nil}
  /// Clears the value of `deviceAuthzenVersion`. Subsequent reads from it will return its default value.
  mutating func clearDeviceAuthzenVersion() {_uniqueStorage()._deviceAuthzenVersion = nil}

  /// Not all devices have device identifiers that fit in 64 bits.
  var longDeviceID: Data {
    get {return _storage._longDeviceID ?? Data()}
    set {_uniqueStorage()._longDeviceID = newValue}
  }
  /// Returns true if `longDeviceID` has been explicitly set.
  var hasLongDeviceID: Bool {return _storage._longDeviceID != nil}
  /// Clears the value of `longDeviceID`. Subsequent reads from it will return its default value.
  mutating func clearLongDeviceID() {_uniqueStorage()._longDeviceID = nil}

  /// The device manufacturer name
  /// (e.g., android.os.Build.MANUFACTURER)
  var deviceManufacturer: String {
    get {return _storage._deviceManufacturer ?? String()}
    set {_uniqueStorage()._deviceManufacturer = newValue}
  }
  /// Returns true if `deviceManufacturer` has been explicitly set.
  var hasDeviceManufacturer: Bool {return _storage._deviceManufacturer != nil}
  /// Clears the value of `deviceManufacturer`. Subsequent reads from it will return its default value.
  mutating func clearDeviceManufacturer() {_uniqueStorage()._deviceManufacturer = nil}

  /// Used to indicate which type of device this is.
  var deviceType: Securegcm_DeviceType {
    get {return _storage._deviceType ?? .android}
    set {_uniqueStorage()._deviceType = newValue}
  }
  /// Returns true if `deviceType` has been explicitly set.
  var hasDeviceType: Bool {return _storage._deviceType != nil}
  /// Clears the value of `deviceType`. Subsequent reads from it will return its default value.
  mutating func clearDeviceType() {_uniqueStorage()._deviceType = nil}

  /// Is this device using  a secure screenlock (e.g., pattern or pin unlock)
  var usingSecureScreenlock: Bool {
    get {return _storage._usingSecureScreenlock ?? false}
    set {_uniqueStorage()._usingSecureScreenlock = newValue}
  }
  /// Returns true if `usingSecureScreenlock` has been explicitly set.
  var hasUsingSecureScreenlock: Bool {return _storage._usingSecureScreenlock != nil}
  /// Clears the value of `usingSecureScreenlock`. Subsequent reads from it will return its default value.
  mutating func clearUsingSecureScreenlock() {_uniqueStorage()._usingSecureScreenlock = nil}

  /// Is auto-unlocking the screenlock (e.g., when at "home") supported?
  var autoUnlockScreenlockSupported: Bool {
    get {return _storage._autoUnlockScreenlockSupported ?? false}
    set {_uniqueStorage()._autoUnlockScreenlockSupported = newValue}
  }
  /// Returns true if `autoUnlockScreenlockSupported` has been explicitly set.
  var hasAutoUnlockScreenlockSupported: Bool {return _storage._autoUnlockScreenlockSupported != nil}
  /// Clears the value of `autoUnlockScreenlockSupported`. Subsequent reads from it will return its default value.
  mutating func clearAutoUnlockScreenlockSupported() {_uniqueStorage()._autoUnlockScreenlockSupported = nil}

  /// Is auto-unlocking the screenlock (e.g., when at "home") enabled?
  var autoUnlockScreenlockEnabled: Bool {
    get {return _storage._autoUnlockScreenlockEnabled ?? false}
    set {_uniqueStorage()._autoUnlockScreenlockEnabled = newValue}
  }
  /// Returns true if `autoUnlockScreenlockEnabled` has been explicitly set.
  var hasAutoUnlockScreenlockEnabled: Bool {return _storage._autoUnlockScreenlockEnabled != nil}
  /// Clears the value of `autoUnlockScreenlockEnabled`. Subsequent reads from it will return its default value.
  mutating func clearAutoUnlockScreenlockEnabled() {_uniqueStorage()._autoUnlockScreenlockEnabled = nil}

  /// Does the device have a Bluetooth (classic) radio?
  var bluetoothRadioSupported: Bool {
    get {return _storage._bluetoothRadioSupported ?? false}
    set {_uniqueStorage()._bluetoothRadioSupported = newValue}
  }
  /// Returns true if `bluetoothRadioSupported` has been explicitly set.
  var hasBluetoothRadioSupported: Bool {return _storage._bluetoothRadioSupported != nil}
  /// Clears the value of `bluetoothRadioSupported`. Subsequent reads from it will return its default value.
  mutating func clearBluetoothRadioSupported() {_uniqueStorage()._bluetoothRadioSupported = nil}

  /// Is the Bluetooth (classic) radio on?
  var bluetoothRadioEnabled: Bool {
    get {return _storage._bluetoothRadioEnabled ?? false}
    set {_uniqueStorage()._bluetoothRadioEnabled = newValue}
  }
  /// Returns true if `bluetoothRadioEnabled` has been explicitly set.
  var hasBluetoothRadioEnabled: Bool {return _storage._bluetoothRadioEnabled != nil}
  /// Clears the value of `bluetoothRadioEnabled`. Subsequent reads from it will return its default value.
  mutating func clearBluetoothRadioEnabled() {_uniqueStorage()._bluetoothRadioEnabled = nil}

  /// Does the device hardware support a mobile data connection?
  var mobileDataSupported: Bool {
    get {return _storage._mobileDataSupported ?? false}
    set {_uniqueStorage()._mobileDataSupported = newValue}
  }
  /// Returns true if `mobileDataSupported` has been explicitly set.
  var hasMobileDataSupported: Bool {return _storage._mobileDataSupported != nil}
  /// Clears the value of `mobileDataSupported`. Subsequent reads from it will return its default value.
  mutating func clearMobileDataSupported() {_uniqueStorage()._mobileDataSupported = nil}

  /// Does the device support tethering?
  var tetheringSupported: Bool {
    get {return _storage._tetheringSupported ?? false}
    set {_uniqueStorage()._tetheringSupported = newValue}
  }
  /// Returns true if `tetheringSupported` has been explicitly set.
  var hasTetheringSupported: Bool {return _storage._tetheringSupported != nil}
  /// Clears the value of `tetheringSupported`. Subsequent reads from it will return its default value.
  mutating func clearTetheringSupported() {_uniqueStorage()._tetheringSupported = nil}

  /// Does the device have a BLE radio?
  var bleRadioSupported: Bool {
    get {return _storage._bleRadioSupported ?? false}
    set {_uniqueStorage()._bleRadioSupported = newValue}
  }
  /// Returns true if `bleRadioSupported` has been explicitly set.
  var hasBleRadioSupported: Bool {return _storage._bleRadioSupported != nil}
  /// Clears the value of `bleRadioSupported`. Subsequent reads from it will return its default value.
  mutating func clearBleRadioSupported() {_uniqueStorage()._bleRadioSupported = nil}

  /// Is the device a "Pixel Experience" Android device?
  var pixelExperience: Bool {
    get {return _storage._pixelExperience ?? false}
    set {_uniqueStorage()._pixelExperience = newValue}
  }
  /// Returns true if `pixelExperience` has been explicitly set.
  var hasPixelExperience: Bool {return _storage._pixelExperience != nil}
  /// Clears the value of `pixelExperience`. Subsequent reads from it will return its default value.
  mutating func clearPixelExperience() {_uniqueStorage()._pixelExperience = nil}

  /// Is the device running in the ARC++ container on a chromebook?
  var arcPlusPlus: Bool {
    get {return _storage._arcPlusPlus ?? false}
    set {_uniqueStorage()._arcPlusPlus = newValue}
  }
  /// Returns true if `arcPlusPlus` has been explicitly set.
  var hasArcPlusPlus: Bool {return _storage._arcPlusPlus != nil}
  /// Clears the value of `arcPlusPlus`. Subsequent reads from it will return its default value.
  mutating func clearArcPlusPlus() {_uniqueStorage()._arcPlusPlus = nil}

  /// Is the value set in |using_secure_screenlock| reliable? On some Android
  /// devices, the platform API to get the screenlock state is not trustworthy.
  /// See b/32212161.
  var isScreenlockStateFlaky: Bool {
    get {return _storage._isScreenlockStateFlaky ?? false}
    set {_uniqueStorage()._isScreenlockStateFlaky = newValue}
  }
  /// Returns true if `isScreenlockStateFlaky` has been explicitly set.
  var hasIsScreenlockStateFlaky: Bool {return _storage._isScreenlockStateFlaky != nil}
  /// Clears the value of `isScreenlockStateFlaky`. Subsequent reads from it will return its default value.
  mutating func clearIsScreenlockStateFlaky() {_uniqueStorage()._isScreenlockStateFlaky = nil}

  /// A list of multi-device software features supported by the device.
  var supportedSoftwareFeatures: [Securegcm_SoftwareFeature] {
    get {return _storage._supportedSoftwareFeatures}
    set {_uniqueStorage()._supportedSoftwareFeatures = newValue}
  }

  /// A list of multi-device software features currently enabled (active) on the
  /// device.
  var enabledSoftwareFeatures: [Securegcm_SoftwareFeature] {
    get {return _storage._enabledSoftwareFeatures}
    set {_uniqueStorage()._enabledSoftwareFeatures = newValue}
  }

  /// The enrollment session id this is sent with
  var enrollmentSessionID: Data {
    get {return _storage._enrollmentSessionID ?? Data()}
    set {_uniqueStorage()._enrollmentSessionID = newValue}
  }
  /// Returns true if `enrollmentSessionID` has been explicitly set.
  var hasEnrollmentSessionID: Bool {return _storage._enrollmentSessionID != nil}
  /// Clears the value of `enrollmentSessionID`. Subsequent reads from it will return its default value.
  mutating func clearEnrollmentSessionID() {_uniqueStorage()._enrollmentSessionID = nil}

  /// A copy of the user's OAuth token
  var oauthToken: String {
    get {return _storage._oauthToken ?? String()}
    set {_uniqueStorage()._oauthToken = newValue}
  }
  /// Returns true if `oauthToken` has been explicitly set.
  var hasOauthToken: Bool {return _storage._oauthToken != nil}
  /// Clears the value of `oauthToken`. Subsequent reads from it will return its default value.
  mutating func clearOauthToken() {_uniqueStorage()._oauthToken = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Securegcm_GcmMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Securegcm_Type {
    get {return _type ?? .enrollment}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var version: Int32 {
    get {return _version ?? 0}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {self._version = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _type: Securegcm_Type? = nil
  fileprivate var _version: Int32? = nil
}

struct Securegcm_Tickle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Time after which this tickle should expire
  var expiryTime: UInt64 {
    get {return _expiryTime ?? 0}
    set {_expiryTime = newValue}
  }
  /// Returns true if `expiryTime` has been explicitly set.
  var hasExpiryTime: Bool {return self._expiryTime != nil}
  /// Clears the value of `expiryTime`. Subsequent reads from it will return its default value.
  mutating func clearExpiryTime() {self._expiryTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _expiryTime: UInt64? = nil
}

struct Securegcm_LoginNotificationInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Time at which the server received the login notification request.
  var creationTime: UInt64 {
    get {return _creationTime ?? 0}
    set {_creationTime = newValue}
  }
  /// Returns true if `creationTime` has been explicitly set.
  var hasCreationTime: Bool {return self._creationTime != nil}
  /// Clears the value of `creationTime`. Subsequent reads from it will return its default value.
  mutating func clearCreationTime() {self._creationTime = nil}

  /// Must correspond to user_id in LoginNotificationRequest, if set.
  var email: String {
    get {return _email ?? String()}
    set {_email = newValue}
  }
  /// Returns true if `email` has been explicitly set.
  var hasEmail: Bool {return self._email != nil}
  /// Clears the value of `email`. Subsequent reads from it will return its default value.
  mutating func clearEmail() {self._email = nil}

  /// Host where the user's credentials were used to login, if meaningful.
  var host: String {
    get {return _host ?? String()}
    set {_host = newValue}
  }
  /// Returns true if `host` has been explicitly set.
  var hasHost: Bool {return self._host != nil}
  /// Clears the value of `host`. Subsequent reads from it will return its default value.
  mutating func clearHost() {self._host = nil}

  /// Location from where the user's credentials were used, if meaningful.
  var source: String {
    get {return _source ?? String()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  mutating func clearSource() {self._source = nil}

  /// Type of login, e.g. ssh, gnome-screensaver, or web.
  var eventType: String {
    get {return _eventType ?? String()}
    set {_eventType = newValue}
  }
  /// Returns true if `eventType` has been explicitly set.
  var hasEventType: Bool {return self._eventType != nil}
  /// Clears the value of `eventType`. Subsequent reads from it will return its default value.
  mutating func clearEventType() {self._eventType = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _creationTime: UInt64? = nil
  fileprivate var _email: String? = nil
  fileprivate var _host: String? = nil
  fileprivate var _source: String? = nil
  fileprivate var _eventType: String? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Securegcm_AppleDeviceDiagonalMils: @unchecked Sendable {}
extension Securegcm_DeviceType: @unchecked Sendable {}
extension Securegcm_SoftwareFeature: @unchecked Sendable {}
extension Securegcm_InvocationReason: @unchecked Sendable {}
extension Securegcm_Type: @unchecked Sendable {}
extension Securegcm_GcmDeviceInfo: @unchecked Sendable {}
extension Securegcm_GcmMetadata: @unchecked Sendable {}
extension Securegcm_Tickle: @unchecked Sendable {}
extension Securegcm_LoginNotificationInfo: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "securegcm"

extension Securegcm_AppleDeviceDiagonalMils: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4000: .same(proto: "APPLE_PHONE"),
    7900: .same(proto: "APPLE_PAD"),
  ]
}

extension Securegcm_DeviceType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "ANDROID"),
    2: .same(proto: "CHROME"),
    3: .same(proto: "IOS"),
    4: .same(proto: "BROWSER"),
    5: .same(proto: "OSX"),
  ]
}

extension Securegcm_SoftwareFeature: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_FEATURE"),
    1: .same(proto: "BETTER_TOGETHER_HOST"),
    2: .same(proto: "BETTER_TOGETHER_CLIENT"),
    3: .same(proto: "EASY_UNLOCK_HOST"),
    4: .same(proto: "EASY_UNLOCK_CLIENT"),
    5: .same(proto: "MAGIC_TETHER_HOST"),
    6: .same(proto: "MAGIC_TETHER_CLIENT"),
    7: .same(proto: "SMS_CONNECT_HOST"),
    8: .same(proto: "SMS_CONNECT_CLIENT"),
  ]
}

extension Securegcm_InvocationReason: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REASON_UNKNOWN"),
    1: .same(proto: "REASON_INITIALIZATION"),
    2: .same(proto: "REASON_PERIODIC"),
    3: .same(proto: "REASON_SLOW_PERIODIC"),
    4: .same(proto: "REASON_FAST_PERIODIC"),
    5: .same(proto: "REASON_EXPIRATION"),
    6: .same(proto: "REASON_FAILURE_RECOVERY"),
    7: .same(proto: "REASON_NEW_ACCOUNT"),
    8: .same(proto: "REASON_CHANGED_ACCOUNT"),
    9: .same(proto: "REASON_FEATURE_TOGGLED"),
    10: .same(proto: "REASON_SERVER_INITIATED"),
    11: .same(proto: "REASON_ADDRESS_CHANGE"),
    12: .same(proto: "REASON_SOFTWARE_UPDATE"),
    13: .same(proto: "REASON_MANUAL"),
    14: .same(proto: "REASON_CUSTOM_KEY_INVALIDATION"),
    15: .same(proto: "REASON_PROXIMITY_PERIODIC"),
  ]
}

extension Securegcm_Type: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ENROLLMENT"),
    1: .same(proto: "TICKLE"),
    2: .same(proto: "TX_REQUEST"),
    3: .same(proto: "TX_REPLY"),
    4: .same(proto: "TX_SYNC_REQUEST"),
    5: .same(proto: "TX_SYNC_RESPONSE"),
    6: .same(proto: "TX_PING"),
    7: .same(proto: "DEVICE_INFO_UPDATE"),
    8: .same(proto: "TX_CANCEL_REQUEST"),
    10: .same(proto: "PROXIMITYAUTH_PAIRING"),
    11: .same(proto: "GCMV1_IDENTITY_ASSERTION"),
    12: .same(proto: "DEVICE_TO_DEVICE_RESPONDER_HELLO_PAYLOAD"),
    13: .same(proto: "DEVICE_TO_DEVICE_MESSAGE"),
    14: .same(proto: "DEVICE_PROXIMITY_CALLBACK"),
    15: .same(proto: "UNLOCK_KEY_SIGNED_CHALLENGE"),
    101: .same(proto: "LOGIN_NOTIFICATION"),
  ]
}

extension Securegcm_GcmDeviceInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GcmDeviceInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "android_device_id"),
    102: .standard(proto: "gcm_registration_id"),
    202: .standard(proto: "apn_registration_id"),
    203: .standard(proto: "notification_enabled"),
    302: .standard(proto: "bluetooth_mac_address"),
    103: .standard(proto: "device_master_key_hash"),
    4: .standard(proto: "user_public_key"),
    7: .standard(proto: "device_model"),
    8: .same(proto: "locale"),
    9: .standard(proto: "key_handle"),
    12: .same(proto: "counter"),
    13: .standard(proto: "device_os_version"),
    14: .standard(proto: "device_os_version_code"),
    15: .standard(proto: "device_os_release"),
    16: .standard(proto: "device_os_codename"),
    17: .standard(proto: "device_software_version"),
    18: .standard(proto: "device_software_version_code"),
    19: .standard(proto: "device_software_package"),
    22: .standard(proto: "device_display_diagonal_mils"),
    24: .standard(proto: "device_authzen_version"),
    29: .standard(proto: "long_device_id"),
    31: .standard(proto: "device_manufacturer"),
    32: .standard(proto: "device_type"),
    400: .standard(proto: "using_secure_screenlock"),
    401: .standard(proto: "auto_unlock_screenlock_supported"),
    402: .standard(proto: "auto_unlock_screenlock_enabled"),
    403: .standard(proto: "bluetooth_radio_supported"),
    404: .standard(proto: "bluetooth_radio_enabled"),
    405: .standard(proto: "mobile_data_supported"),
    406: .standard(proto: "tethering_supported"),
    407: .standard(proto: "ble_radio_supported"),
    408: .standard(proto: "pixel_experience"),
    409: .standard(proto: "arc_plus_plus"),
    410: .standard(proto: "is_screenlock_state_flaky"),
    411: .standard(proto: "supported_software_features"),
    412: .standard(proto: "enabled_software_features"),
    1000: .standard(proto: "enrollment_session_id"),
    1001: .standard(proto: "oauth_token"),
  ]

  fileprivate class _StorageClass {
    var _androidDeviceID: UInt64? = nil
    var _gcmRegistrationID: Data? = nil
    var _apnRegistrationID: Data? = nil
    var _notificationEnabled: Bool? = nil
    var _bluetoothMacAddress: String? = nil
    var _deviceMasterKeyHash: Data? = nil
    var _userPublicKey: Data? = nil
    var _deviceModel: String? = nil
    var _locale: String? = nil
    var _keyHandle: Data? = nil
    var _counter: Int64? = nil
    var _deviceOsVersion: String? = nil
    var _deviceOsVersionCode: Int64? = nil
    var _deviceOsRelease: String? = nil
    var _deviceOsCodename: String? = nil
    var _deviceSoftwareVersion: String? = nil
    var _deviceSoftwareVersionCode: Int64? = nil
    var _deviceSoftwarePackage: String? = nil
    var _deviceDisplayDiagonalMils: Int32? = nil
    var _deviceAuthzenVersion: Int32? = nil
    var _longDeviceID: Data? = nil
    var _deviceManufacturer: String? = nil
    var _deviceType: Securegcm_DeviceType? = nil
    var _usingSecureScreenlock: Bool? = nil
    var _autoUnlockScreenlockSupported: Bool? = nil
    var _autoUnlockScreenlockEnabled: Bool? = nil
    var _bluetoothRadioSupported: Bool? = nil
    var _bluetoothRadioEnabled: Bool? = nil
    var _mobileDataSupported: Bool? = nil
    var _tetheringSupported: Bool? = nil
    var _bleRadioSupported: Bool? = nil
    var _pixelExperience: Bool? = nil
    var _arcPlusPlus: Bool? = nil
    var _isScreenlockStateFlaky: Bool? = nil
    var _supportedSoftwareFeatures: [Securegcm_SoftwareFeature] = []
    var _enabledSoftwareFeatures: [Securegcm_SoftwareFeature] = []
    var _enrollmentSessionID: Data? = nil
    var _oauthToken: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _androidDeviceID = source._androidDeviceID
      _gcmRegistrationID = source._gcmRegistrationID
      _apnRegistrationID = source._apnRegistrationID
      _notificationEnabled = source._notificationEnabled
      _bluetoothMacAddress = source._bluetoothMacAddress
      _deviceMasterKeyHash = source._deviceMasterKeyHash
      _userPublicKey = source._userPublicKey
      _deviceModel = source._deviceModel
      _locale = source._locale
      _keyHandle = source._keyHandle
      _counter = source._counter
      _deviceOsVersion = source._deviceOsVersion
      _deviceOsVersionCode = source._deviceOsVersionCode
      _deviceOsRelease = source._deviceOsRelease
      _deviceOsCodename = source._deviceOsCodename
      _deviceSoftwareVersion = source._deviceSoftwareVersion
      _deviceSoftwareVersionCode = source._deviceSoftwareVersionCode
      _deviceSoftwarePackage = source._deviceSoftwarePackage
      _deviceDisplayDiagonalMils = source._deviceDisplayDiagonalMils
      _deviceAuthzenVersion = source._deviceAuthzenVersion
      _longDeviceID = source._longDeviceID
      _deviceManufacturer = source._deviceManufacturer
      _deviceType = source._deviceType
      _usingSecureScreenlock = source._usingSecureScreenlock
      _autoUnlockScreenlockSupported = source._autoUnlockScreenlockSupported
      _autoUnlockScreenlockEnabled = source._autoUnlockScreenlockEnabled
      _bluetoothRadioSupported = source._bluetoothRadioSupported
      _bluetoothRadioEnabled = source._bluetoothRadioEnabled
      _mobileDataSupported = source._mobileDataSupported
      _tetheringSupported = source._tetheringSupported
      _bleRadioSupported = source._bleRadioSupported
      _pixelExperience = source._pixelExperience
      _arcPlusPlus = source._arcPlusPlus
      _isScreenlockStateFlaky = source._isScreenlockStateFlaky
      _supportedSoftwareFeatures = source._supportedSoftwareFeatures
      _enabledSoftwareFeatures = source._enabledSoftwareFeatures
      _enrollmentSessionID = source._enrollmentSessionID
      _oauthToken = source._oauthToken
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._userPublicKey == nil {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularFixed64Field(value: &_storage._androidDeviceID) }()
        case 4: try { try decoder.decodeSingularBytesField(value: &_storage._userPublicKey) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._deviceModel) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._locale) }()
        case 9: try { try decoder.decodeSingularBytesField(value: &_storage._keyHandle) }()
        case 12: try { try decoder.decodeSingularInt64Field(value: &_storage._counter) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._deviceOsVersion) }()
        case 14: try { try decoder.decodeSingularInt64Field(value: &_storage._deviceOsVersionCode) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._deviceOsRelease) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._deviceOsCodename) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._deviceSoftwareVersion) }()
        case 18: try { try decoder.decodeSingularInt64Field(value: &_storage._deviceSoftwareVersionCode) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._deviceSoftwarePackage) }()
        case 22: try { try decoder.decodeSingularInt32Field(value: &_storage._deviceDisplayDiagonalMils) }()
        case 24: try { try decoder.decodeSingularInt32Field(value: &_storage._deviceAuthzenVersion) }()
        case 29: try { try decoder.decodeSingularBytesField(value: &_storage._longDeviceID) }()
        case 31: try { try decoder.decodeSingularStringField(value: &_storage._deviceManufacturer) }()
        case 32: try { try decoder.decodeSingularEnumField(value: &_storage._deviceType) }()
        case 102: try { try decoder.decodeSingularBytesField(value: &_storage._gcmRegistrationID) }()
        case 103: try { try decoder.decodeSingularBytesField(value: &_storage._deviceMasterKeyHash) }()
        case 202: try { try decoder.decodeSingularBytesField(value: &_storage._apnRegistrationID) }()
        case 203: try { try decoder.decodeSingularBoolField(value: &_storage._notificationEnabled) }()
        case 302: try { try decoder.decodeSingularStringField(value: &_storage._bluetoothMacAddress) }()
        case 400: try { try decoder.decodeSingularBoolField(value: &_storage._usingSecureScreenlock) }()
        case 401: try { try decoder.decodeSingularBoolField(value: &_storage._autoUnlockScreenlockSupported) }()
        case 402: try { try decoder.decodeSingularBoolField(value: &_storage._autoUnlockScreenlockEnabled) }()
        case 403: try { try decoder.decodeSingularBoolField(value: &_storage._bluetoothRadioSupported) }()
        case 404: try { try decoder.decodeSingularBoolField(value: &_storage._bluetoothRadioEnabled) }()
        case 405: try { try decoder.decodeSingularBoolField(value: &_storage._mobileDataSupported) }()
        case 406: try { try decoder.decodeSingularBoolField(value: &_storage._tetheringSupported) }()
        case 407: try { try decoder.decodeSingularBoolField(value: &_storage._bleRadioSupported) }()
        case 408: try { try decoder.decodeSingularBoolField(value: &_storage._pixelExperience) }()
        case 409: try { try decoder.decodeSingularBoolField(value: &_storage._arcPlusPlus) }()
        case 410: try { try decoder.decodeSingularBoolField(value: &_storage._isScreenlockStateFlaky) }()
        case 411: try { try decoder.decodeRepeatedEnumField(value: &_storage._supportedSoftwareFeatures) }()
        case 412: try { try decoder.decodeRepeatedEnumField(value: &_storage._enabledSoftwareFeatures) }()
        case 1000: try { try decoder.decodeSingularBytesField(value: &_storage._enrollmentSessionID) }()
        case 1001: try { try decoder.decodeSingularStringField(value: &_storage._oauthToken) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._androidDeviceID {
        try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._userPublicKey {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._deviceModel {
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._locale {
        try visitor.visitSingularStringField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._keyHandle {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._counter {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._deviceOsVersion {
        try visitor.visitSingularStringField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._deviceOsVersionCode {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._deviceOsRelease {
        try visitor.visitSingularStringField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._deviceOsCodename {
        try visitor.visitSingularStringField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._deviceSoftwareVersion {
        try visitor.visitSingularStringField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._deviceSoftwareVersionCode {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._deviceSoftwarePackage {
        try visitor.visitSingularStringField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._deviceDisplayDiagonalMils {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._deviceAuthzenVersion {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 24)
      } }()
      try { if let v = _storage._longDeviceID {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 29)
      } }()
      try { if let v = _storage._deviceManufacturer {
        try visitor.visitSingularStringField(value: v, fieldNumber: 31)
      } }()
      try { if let v = _storage._deviceType {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 32)
      } }()
      try { if let v = _storage._gcmRegistrationID {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 102)
      } }()
      try { if let v = _storage._deviceMasterKeyHash {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 103)
      } }()
      try { if let v = _storage._apnRegistrationID {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 202)
      } }()
      try { if let v = _storage._notificationEnabled {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 203)
      } }()
      try { if let v = _storage._bluetoothMacAddress {
        try visitor.visitSingularStringField(value: v, fieldNumber: 302)
      } }()
      try { if let v = _storage._usingSecureScreenlock {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 400)
      } }()
      try { if let v = _storage._autoUnlockScreenlockSupported {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 401)
      } }()
      try { if let v = _storage._autoUnlockScreenlockEnabled {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 402)
      } }()
      try { if let v = _storage._bluetoothRadioSupported {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 403)
      } }()
      try { if let v = _storage._bluetoothRadioEnabled {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 404)
      } }()
      try { if let v = _storage._mobileDataSupported {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 405)
      } }()
      try { if let v = _storage._tetheringSupported {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 406)
      } }()
      try { if let v = _storage._bleRadioSupported {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 407)
      } }()
      try { if let v = _storage._pixelExperience {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 408)
      } }()
      try { if let v = _storage._arcPlusPlus {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 409)
      } }()
      try { if let v = _storage._isScreenlockStateFlaky {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 410)
      } }()
      if !_storage._supportedSoftwareFeatures.isEmpty {
        try visitor.visitRepeatedEnumField(value: _storage._supportedSoftwareFeatures, fieldNumber: 411)
      }
      if !_storage._enabledSoftwareFeatures.isEmpty {
        try visitor.visitRepeatedEnumField(value: _storage._enabledSoftwareFeatures, fieldNumber: 412)
      }
      try { if let v = _storage._enrollmentSessionID {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 1000)
      } }()
      try { if let v = _storage._oauthToken {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1001)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Securegcm_GcmDeviceInfo, rhs: Securegcm_GcmDeviceInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._androidDeviceID != rhs_storage._androidDeviceID {return false}
        if _storage._gcmRegistrationID != rhs_storage._gcmRegistrationID {return false}
        if _storage._apnRegistrationID != rhs_storage._apnRegistrationID {return false}
        if _storage._notificationEnabled != rhs_storage._notificationEnabled {return false}
        if _storage._bluetoothMacAddress != rhs_storage._bluetoothMacAddress {return false}
        if _storage._deviceMasterKeyHash != rhs_storage._deviceMasterKeyHash {return false}
        if _storage._userPublicKey != rhs_storage._userPublicKey {return false}
        if _storage._deviceModel != rhs_storage._deviceModel {return false}
        if _storage._locale != rhs_storage._locale {return false}
        if _storage._keyHandle != rhs_storage._keyHandle {return false}
        if _storage._counter != rhs_storage._counter {return false}
        if _storage._deviceOsVersion != rhs_storage._deviceOsVersion {return false}
        if _storage._deviceOsVersionCode != rhs_storage._deviceOsVersionCode {return false}
        if _storage._deviceOsRelease != rhs_storage._deviceOsRelease {return false}
        if _storage._deviceOsCodename != rhs_storage._deviceOsCodename {return false}
        if _storage._deviceSoftwareVersion != rhs_storage._deviceSoftwareVersion {return false}
        if _storage._deviceSoftwareVersionCode != rhs_storage._deviceSoftwareVersionCode {return false}
        if _storage._deviceSoftwarePackage != rhs_storage._deviceSoftwarePackage {return false}
        if _storage._deviceDisplayDiagonalMils != rhs_storage._deviceDisplayDiagonalMils {return false}
        if _storage._deviceAuthzenVersion != rhs_storage._deviceAuthzenVersion {return false}
        if _storage._longDeviceID != rhs_storage._longDeviceID {return false}
        if _storage._deviceManufacturer != rhs_storage._deviceManufacturer {return false}
        if _storage._deviceType != rhs_storage._deviceType {return false}
        if _storage._usingSecureScreenlock != rhs_storage._usingSecureScreenlock {return false}
        if _storage._autoUnlockScreenlockSupported != rhs_storage._autoUnlockScreenlockSupported {return false}
        if _storage._autoUnlockScreenlockEnabled != rhs_storage._autoUnlockScreenlockEnabled {return false}
        if _storage._bluetoothRadioSupported != rhs_storage._bluetoothRadioSupported {return false}
        if _storage._bluetoothRadioEnabled != rhs_storage._bluetoothRadioEnabled {return false}
        if _storage._mobileDataSupported != rhs_storage._mobileDataSupported {return false}
        if _storage._tetheringSupported != rhs_storage._tetheringSupported {return false}
        if _storage._bleRadioSupported != rhs_storage._bleRadioSupported {return false}
        if _storage._pixelExperience != rhs_storage._pixelExperience {return false}
        if _storage._arcPlusPlus != rhs_storage._arcPlusPlus {return false}
        if _storage._isScreenlockStateFlaky != rhs_storage._isScreenlockStateFlaky {return false}
        if _storage._supportedSoftwareFeatures != rhs_storage._supportedSoftwareFeatures {return false}
        if _storage._enabledSoftwareFeatures != rhs_storage._enabledSoftwareFeatures {return false}
        if _storage._enrollmentSessionID != rhs_storage._enrollmentSessionID {return false}
        if _storage._oauthToken != rhs_storage._oauthToken {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Securegcm_GcmMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GcmMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "version"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._version) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._version {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Securegcm_GcmMetadata, rhs: Securegcm_GcmMetadata) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._version != rhs._version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Securegcm_Tickle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Tickle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "expiry_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._expiryTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._expiryTime {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Securegcm_Tickle, rhs: Securegcm_Tickle) -> Bool {
    if lhs._expiryTime != rhs._expiryTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Securegcm_LoginNotificationInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LoginNotificationInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "creation_time"),
    3: .same(proto: "email"),
    4: .same(proto: "host"),
    5: .same(proto: "source"),
    6: .standard(proto: "event_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self._creationTime) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._email) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._host) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._source) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._eventType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._creationTime {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._email {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._host {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._source {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._eventType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Securegcm_LoginNotificationInfo, rhs: Securegcm_LoginNotificationInfo) -> Bool {
    if lhs._creationTime != rhs._creationTime {return false}
    if lhs._email != rhs._email {return false}
    if lhs._host != rhs._host {return false}
    if lhs._source != rhs._source {return false}
    if lhs._eventType != rhs._eventType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
