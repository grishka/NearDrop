// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: sharing_enums.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// We use event based logging (an event object can be constructed and logged
/// immediately when they occur). To obtain session based information (e.g.
/// durations, counting incoming introductions), we use flowId (sender/receiver)
/// in NearbyClearcutLogger (for android, or clearcut_event_logger as the
/// equivalence for Windows) for all events (may exclude settings), and
/// session_id for a pair of events (start and end of a session).
/// Next id: 74
enum Location_Nearby_Proto_Sharing_EventType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownEventType // = 0

  /// When new users accept agreements (like grant permission to contacts for
  /// CONTACT_ONLY visibility) and are enrolled into Nearby Sharing. This event
  /// is used to count number of new users.
  case acceptAgreements // = 1

  /// User enables/disables nearby sharing from setting or tile service.
  case enableNearbySharing // = 2

  /// User sets visibility preference from setting.
  case setVisibility // = 3

  /// Describe attachments immediately when Nearby Sharing is opened by another
  /// app which is used to generate/attach attachments to be shared with other
  /// devices.
  case describeAttachments // = 4

  /// Start of a scanning phase at sender.
  case scanForShareTargetsStart // = 5

  /// End of the scanning phase at sender.
  case scanForShareTargetsEnd // = 6

  /// Receiver advertises itself for presence (a pseudo session).
  case advertiseDevicePresenceStart // = 7

  /// End of the advertising phase at receiver.
  case advertiseDevicePresenceEnd // = 8

  /// Sender sends a fast initialization to receiver.
  case sendFastInitialization // = 9

  /// Receiver receives the fast initialization.
  case receiveFastInitialization // = 10

  /// Sender discovers a share target.
  case discoverShareTarget // = 11

  /// Sender sends introduction (before attachments being sent).
  case sendIntroduction // = 12

  /// Receiver receives introduction.
  case receiveIntroduction // = 13

  /// Receiver responds to introduction (before attachments being sent).
  /// Actions: Accept, Reject, or (for some reason) Fail.
  case respondToIntroduction // = 14

  /// Start of the sending attachments phase at sender.
  case sendAttachmentsStart // = 15

  /// End of sending attachments phase at sender.
  case sendAttachmentsEnd // = 16

  /// Start of the receiving attachments phase at receiver.
  case receiveAttachmentsStart // = 17

  /// End of receiving attachments phase at receiver.
  case receiveAttachmentsEnd // = 18

  /// Sender cancels sending attachments.
  case cancelSendingAttachments // = 19

  /// Receiver cancels receiving attachments.
  case cancelReceivingAttachments // = 20

  /// Receiver opens received attachments.
  case openReceivedAttachments // = 21

  /// User opens the setup activity.
  case launchSetupActivity // = 22

  /// User adds a contact.
  case addContact // = 23

  /// User removes a contact.
  case removeContact // = 24

  /// Local devices all Fast Share server.
  case fastShareServerResponse // = 25

  /// The start of a sending session.
  case sendStart // = 26

  /// Receiver accepts a fast initialization.
  case acceptFastInitialization // = 27

  /// Set data usage preference.
  case setDataUsage // = 28

  /// Receiver dismisses a fast initialization
  case dismissFastInitialization // = 29

  /// Cancel connection.
  case cancelConnection // = 30

  /// User starts a chimera activity (e.g. ConsentsChimeraActivity,
  /// DeviceVisibilityChimeraActivity...)
  case launchActivity // = 31

  /// Receiver dismisses a privacy notification.
  case dismissPrivacyNotification // = 32

  /// Receiver taps a privacy notification.
  case tapPrivacyNotification // = 33

  /// Receiver taps a help page.
  case tapHelp // = 34

  /// Receiver taps a feedback.
  case tapFeedback // = 35

  /// Receiver adds quick settings tile.
  case addQuickSettingsTile // = 36

  /// Receiver removes quick settings tile.
  case removeQuickSettingsTile // = 37

  /// Receiver phone consent clicked.
  case launchPhoneConsent // = 38

  /// Devices show a phone consent banner in Nearby Share Settings
  case displayPhoneConsent // = 54

  /// Receiver taps quick settings tile.
  case tapQuickSettingsTile // = 39

  /// Receiver Installation of APKs status.
  case installApk // = 40

  /// Receiver verification of APKs status.
  case verifyApk // = 41

  /// User starts a consent.
  case launchConsent // = 42

  /// After receiving payloads, Nearby Share still needs to transfer the payloads
  /// to correct attachment formats and move files attachments from temporary
  /// directory to final destination.
  case processReceivedAttachmentsEnd // = 43

  /// Toggle Show Notification setting item in Nearby Share setting.
  case toggleShowNotification // = 44

  /// Set device name
  case setDeviceName // = 45

  /// users dropped off opt-in page.
  case declineAgreements // = 46

  /// Request setting permissions (Wifi/BT/location/airplane mode).
  case requestSettingPermissions // = 47

  /// Set up a connection with the remote device.
  case establishConnection // = 48

  /// Track device states in Nearby Share setting.
  case deviceSettings // = 49

  /// Receiver auto dismisses a fast initialization notification.
  case autoDismissFastInitialization // = 50

  /// App Crash event.
  /// Used only for Windows App now.
  case appCrash // = 51

  /// Sender taps the Send button in quick settings
  case tapQuickSettingsFileShare // = 52

  /// Devices show a privacy notification
  case displayPrivacyNotification // = 53

  /// Preference usage event (e.g. load/save preferences, etc).
  /// Used only for Windows App now.
  case preferencesUsage // = 55

  /// Default opt in
  case defaultOptIn // = 56

  /// The result of the setup wizard flow
  case setupWizard // = 57

  /// Sender taps a QR code
  case tapQrCode // = 58

  /// QR code link shown
  case qrCodeLinkShown // = 59

  /// Sender failed to parse endpoint id.
  case parsingFailedEndpointID // = 60

  /// The device is discovered by fast initialization
  case fastInitDiscoverDevice // = 61

  /// Send desktop notification.
  case sendDesktopNotification // = 62

  /// User sets account preference
  case setAccount // = 63

  /// Decrypt certificate failure
  case decryptCertificateFailure // = 64

  /// Show allow permission auto access UI
  case showAllowPermissionAutoAccess // = 65

  /// UI events for transferring files with desktop applications. It includes
  /// event types such as DESKTOP_TRANSFER_EVENT_SEND_TYPE_SELECT_A_DEVICE.
  case sendDesktopTransferEvent // = 66

  /// Show accept button on Quick Share receive UI
  case waitingForAccept // = 67

  /// High quality event setup
  case highQualityMediumSetup // = 68

  /// RPC call status
  case rpcCallStatus // = 69

  /// A QR code sharing session has started
  case startQrCodeSession // = 70

  /// A QR code URL has been opened in a web client/browser instead of in a
  /// native Quick Share app.
  case qrCodeOpenedInWebClient // = 71

  /// A HaTS survey session id has been joined with Quick Share flow id.
  case hatsJointEvent // = 72

  /// Previews received.
  case receivePreviews // = 73

  init() {
    self = .unknownEventType
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownEventType
    case 1: self = .acceptAgreements
    case 2: self = .enableNearbySharing
    case 3: self = .setVisibility
    case 4: self = .describeAttachments
    case 5: self = .scanForShareTargetsStart
    case 6: self = .scanForShareTargetsEnd
    case 7: self = .advertiseDevicePresenceStart
    case 8: self = .advertiseDevicePresenceEnd
    case 9: self = .sendFastInitialization
    case 10: self = .receiveFastInitialization
    case 11: self = .discoverShareTarget
    case 12: self = .sendIntroduction
    case 13: self = .receiveIntroduction
    case 14: self = .respondToIntroduction
    case 15: self = .sendAttachmentsStart
    case 16: self = .sendAttachmentsEnd
    case 17: self = .receiveAttachmentsStart
    case 18: self = .receiveAttachmentsEnd
    case 19: self = .cancelSendingAttachments
    case 20: self = .cancelReceivingAttachments
    case 21: self = .openReceivedAttachments
    case 22: self = .launchSetupActivity
    case 23: self = .addContact
    case 24: self = .removeContact
    case 25: self = .fastShareServerResponse
    case 26: self = .sendStart
    case 27: self = .acceptFastInitialization
    case 28: self = .setDataUsage
    case 29: self = .dismissFastInitialization
    case 30: self = .cancelConnection
    case 31: self = .launchActivity
    case 32: self = .dismissPrivacyNotification
    case 33: self = .tapPrivacyNotification
    case 34: self = .tapHelp
    case 35: self = .tapFeedback
    case 36: self = .addQuickSettingsTile
    case 37: self = .removeQuickSettingsTile
    case 38: self = .launchPhoneConsent
    case 39: self = .tapQuickSettingsTile
    case 40: self = .installApk
    case 41: self = .verifyApk
    case 42: self = .launchConsent
    case 43: self = .processReceivedAttachmentsEnd
    case 44: self = .toggleShowNotification
    case 45: self = .setDeviceName
    case 46: self = .declineAgreements
    case 47: self = .requestSettingPermissions
    case 48: self = .establishConnection
    case 49: self = .deviceSettings
    case 50: self = .autoDismissFastInitialization
    case 51: self = .appCrash
    case 52: self = .tapQuickSettingsFileShare
    case 53: self = .displayPrivacyNotification
    case 54: self = .displayPhoneConsent
    case 55: self = .preferencesUsage
    case 56: self = .defaultOptIn
    case 57: self = .setupWizard
    case 58: self = .tapQrCode
    case 59: self = .qrCodeLinkShown
    case 60: self = .parsingFailedEndpointID
    case 61: self = .fastInitDiscoverDevice
    case 62: self = .sendDesktopNotification
    case 63: self = .setAccount
    case 64: self = .decryptCertificateFailure
    case 65: self = .showAllowPermissionAutoAccess
    case 66: self = .sendDesktopTransferEvent
    case 67: self = .waitingForAccept
    case 68: self = .highQualityMediumSetup
    case 69: self = .rpcCallStatus
    case 70: self = .startQrCodeSession
    case 71: self = .qrCodeOpenedInWebClient
    case 72: self = .hatsJointEvent
    case 73: self = .receivePreviews
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownEventType: return 0
    case .acceptAgreements: return 1
    case .enableNearbySharing: return 2
    case .setVisibility: return 3
    case .describeAttachments: return 4
    case .scanForShareTargetsStart: return 5
    case .scanForShareTargetsEnd: return 6
    case .advertiseDevicePresenceStart: return 7
    case .advertiseDevicePresenceEnd: return 8
    case .sendFastInitialization: return 9
    case .receiveFastInitialization: return 10
    case .discoverShareTarget: return 11
    case .sendIntroduction: return 12
    case .receiveIntroduction: return 13
    case .respondToIntroduction: return 14
    case .sendAttachmentsStart: return 15
    case .sendAttachmentsEnd: return 16
    case .receiveAttachmentsStart: return 17
    case .receiveAttachmentsEnd: return 18
    case .cancelSendingAttachments: return 19
    case .cancelReceivingAttachments: return 20
    case .openReceivedAttachments: return 21
    case .launchSetupActivity: return 22
    case .addContact: return 23
    case .removeContact: return 24
    case .fastShareServerResponse: return 25
    case .sendStart: return 26
    case .acceptFastInitialization: return 27
    case .setDataUsage: return 28
    case .dismissFastInitialization: return 29
    case .cancelConnection: return 30
    case .launchActivity: return 31
    case .dismissPrivacyNotification: return 32
    case .tapPrivacyNotification: return 33
    case .tapHelp: return 34
    case .tapFeedback: return 35
    case .addQuickSettingsTile: return 36
    case .removeQuickSettingsTile: return 37
    case .launchPhoneConsent: return 38
    case .tapQuickSettingsTile: return 39
    case .installApk: return 40
    case .verifyApk: return 41
    case .launchConsent: return 42
    case .processReceivedAttachmentsEnd: return 43
    case .toggleShowNotification: return 44
    case .setDeviceName: return 45
    case .declineAgreements: return 46
    case .requestSettingPermissions: return 47
    case .establishConnection: return 48
    case .deviceSettings: return 49
    case .autoDismissFastInitialization: return 50
    case .appCrash: return 51
    case .tapQuickSettingsFileShare: return 52
    case .displayPrivacyNotification: return 53
    case .displayPhoneConsent: return 54
    case .preferencesUsage: return 55
    case .defaultOptIn: return 56
    case .setupWizard: return 57
    case .tapQrCode: return 58
    case .qrCodeLinkShown: return 59
    case .parsingFailedEndpointID: return 60
    case .fastInitDiscoverDevice: return 61
    case .sendDesktopNotification: return 62
    case .setAccount: return 63
    case .decryptCertificateFailure: return 64
    case .showAllowPermissionAutoAccess: return 65
    case .sendDesktopTransferEvent: return 66
    case .waitingForAccept: return 67
    case .highQualityMediumSetup: return 68
    case .rpcCallStatus: return 69
    case .startQrCodeSession: return 70
    case .qrCodeOpenedInWebClient: return 71
    case .hatsJointEvent: return 72
    case .receivePreviews: return 73
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_EventType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// Event category to differentiate whether this comes from sender or receiver,
/// whether this is for communication flow, or for settings.
enum Location_Nearby_Proto_Sharing_EventCategory: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownEventCategory // = 0
  case sendingEvent // = 1
  case receivingEvent // = 2
  case settingsEvent // = 3
  case rpcEvent // = 4

  init() {
    self = .unknownEventCategory
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownEventCategory
    case 1: self = .sendingEvent
    case 2: self = .receivingEvent
    case 3: self = .settingsEvent
    case 4: self = .rpcEvent
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownEventCategory: return 0
    case .sendingEvent: return 1
    case .receivingEvent: return 2
    case .settingsEvent: return 3
    case .rpcEvent: return 4
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_EventCategory: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// Status of nearby sharing.
enum Location_Nearby_Proto_Sharing_NearbySharingStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownNearbySharingStatus // = 0
  case on // = 1
  case off // = 2

  init() {
    self = .unknownNearbySharingStatus
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownNearbySharingStatus
    case 1: self = .on
    case 2: self = .off
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownNearbySharingStatus: return 0
    case .on: return 1
    case .off: return 2
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_NearbySharingStatus: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum Location_Nearby_Proto_Sharing_Visibility: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownVisibility // = 0
  case contactsOnly // = 1
  case everyone // = 2
  case selectedContactsOnly // = 3
  case hidden // = 4
  case selfShare // = 5

  init() {
    self = .unknownVisibility
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownVisibility
    case 1: self = .contactsOnly
    case 2: self = .everyone
    case 3: self = .selectedContactsOnly
    case 4: self = .hidden
    case 5: self = .selfShare
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownVisibility: return 0
    case .contactsOnly: return 1
    case .everyone: return 2
    case .selectedContactsOnly: return 3
    case .hidden: return 4
    case .selfShare: return 5
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_Visibility: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum Location_Nearby_Proto_Sharing_DataUsage: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownDataUsage // = 0
  case online // = 1
  case wifiOnly // = 2
  case offline // = 3

  init() {
    self = .unknownDataUsage
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownDataUsage
    case 1: self = .online
    case 2: self = .wifiOnly
    case 3: self = .offline
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownDataUsage: return 0
    case .online: return 1
    case .wifiOnly: return 2
    case .offline: return 3
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_DataUsage: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// The status of establishing a connection. Used by ESTABLISH_CONNECTION.
enum Location_Nearby_Proto_Sharing_EstablishConnectionStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case connectionStatusUnknown // = 0
  case connectionStatusSuccess // = 1
  case connectionStatusFailure // = 2
  case connectionStatusCancellation // = 3
  case connectionStatusMediaUnavailableAttachment // = 4
  case connectionStatusFailedPairedKeyhandshake // = 5
  case connectionStatusFailedWriteIntroduction // = 6
  case connectionStatusFailedNullConnection // = 7
  case connectionStatusFailedNoTransferUpdateCallback // = 8
  case connectionStatusLostConnectivity // = 9

  /// TODO: b/341782941 - : Annote this status when it's confirmed by Nearby
  /// Connections team.
  case connectionStatusInvalidAdvertisement // = 10

  init() {
    self = .connectionStatusUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .connectionStatusUnknown
    case 1: self = .connectionStatusSuccess
    case 2: self = .connectionStatusFailure
    case 3: self = .connectionStatusCancellation
    case 4: self = .connectionStatusMediaUnavailableAttachment
    case 5: self = .connectionStatusFailedPairedKeyhandshake
    case 6: self = .connectionStatusFailedWriteIntroduction
    case 7: self = .connectionStatusFailedNullConnection
    case 8: self = .connectionStatusFailedNoTransferUpdateCallback
    case 9: self = .connectionStatusLostConnectivity
    case 10: self = .connectionStatusInvalidAdvertisement
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .connectionStatusUnknown: return 0
    case .connectionStatusSuccess: return 1
    case .connectionStatusFailure: return 2
    case .connectionStatusCancellation: return 3
    case .connectionStatusMediaUnavailableAttachment: return 4
    case .connectionStatusFailedPairedKeyhandshake: return 5
    case .connectionStatusFailedWriteIntroduction: return 6
    case .connectionStatusFailedNullConnection: return 7
    case .connectionStatusFailedNoTransferUpdateCallback: return 8
    case .connectionStatusLostConnectivity: return 9
    case .connectionStatusInvalidAdvertisement: return 10
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_EstablishConnectionStatus: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// The status of sending and receiving attachments. Used by SEND_ATTACHMENTS.
enum Location_Nearby_Proto_Sharing_AttachmentTransmissionStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownAttachmentTransmissionStatus // = 0
  case completeAttachmentTransmissionStatus // = 1
  case canceledAttachmentTransmissionStatus // = 2
  case failedAttachmentTransmissionStatus // = 3
  case rejectedAttachment // = 4
  case timedOutAttachment // = 5
  case awaitingRemoteAcceptanceFailedAttachment // = 6
  case notEnoughSpaceAttachment // = 7
  case failedNoTransferUpdateCallback // = 8
  case mediaUnavailableAttachment // = 9
  case unsupportedAttachmentTypeAttachment // = 10
  case noAttachmentFound // = 11
  case failedNoShareTargetEndpoint // = 12
  case failedPairedKeyhandshake // = 13
  case failedNullConnection // = 14
  case failedNoPayload // = 15
  case failedWriteIntroduction // = 16

  /// The remote response is either missing or has an unknown type.
  case failedUnknownRemoteResponse // = 17

  /// Breakdowns of FAILED_NULL_CONNECTION (Desktop side)
  case failedNullConnectionInitOutgoing // = 18
  case failedNullConnectionDisconnected // = 19

  /// Breakdowns of FAILED_NULL_CONNECTION (android side)
  /// Connection failed due to Wifi is disconnected or Bluetooth setting is off
  /// or user turn on airplane mode.
  case failedNullConnectionLostConnectivity // = 20

  /// Unexpected connection failure.
  case failedNullConnectionFailure // = 21
  case rejectedAttachmentTransmissionStatus // = 22
  case timedOutAttachmentTransmissionStatus // = 23
  case notEnoughSpaceAttachmentTransmissionStatus // = 24
  case unsupportedAttachmentTypeAttachmentTransmissionStatus // = 25
  case failedUnknownRemoteResponseTransmissionStatus // = 26

  /// Connection failed due to Wifi is disconnected or Bluetooth setting is off
  /// or user turn on airplane mode.
  case noResponseFrameConnectionClosedLostConnectivityTransmissionStatus // = 27

  /// Unexpected connection failure due to no response frame.
  case noResponseFrameConnectionClosedTransmissionStatus // = 28

  /// Connection failed due to Wifi is disconnected or Bluetooth setting is off
  /// or user turn on airplane mode.
  case lostConnectivityTransmissionStatus // = 29

  /// Connection failed due to the medium is not allowed.
  case failedDisallowedMedium // = 30

  init() {
    self = .unknownAttachmentTransmissionStatus
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownAttachmentTransmissionStatus
    case 1: self = .completeAttachmentTransmissionStatus
    case 2: self = .canceledAttachmentTransmissionStatus
    case 3: self = .failedAttachmentTransmissionStatus
    case 4: self = .rejectedAttachment
    case 5: self = .timedOutAttachment
    case 6: self = .awaitingRemoteAcceptanceFailedAttachment
    case 7: self = .notEnoughSpaceAttachment
    case 8: self = .failedNoTransferUpdateCallback
    case 9: self = .mediaUnavailableAttachment
    case 10: self = .unsupportedAttachmentTypeAttachment
    case 11: self = .noAttachmentFound
    case 12: self = .failedNoShareTargetEndpoint
    case 13: self = .failedPairedKeyhandshake
    case 14: self = .failedNullConnection
    case 15: self = .failedNoPayload
    case 16: self = .failedWriteIntroduction
    case 17: self = .failedUnknownRemoteResponse
    case 18: self = .failedNullConnectionInitOutgoing
    case 19: self = .failedNullConnectionDisconnected
    case 20: self = .failedNullConnectionLostConnectivity
    case 21: self = .failedNullConnectionFailure
    case 22: self = .rejectedAttachmentTransmissionStatus
    case 23: self = .timedOutAttachmentTransmissionStatus
    case 24: self = .notEnoughSpaceAttachmentTransmissionStatus
    case 25: self = .unsupportedAttachmentTypeAttachmentTransmissionStatus
    case 26: self = .failedUnknownRemoteResponseTransmissionStatus
    case 27: self = .noResponseFrameConnectionClosedLostConnectivityTransmissionStatus
    case 28: self = .noResponseFrameConnectionClosedTransmissionStatus
    case 29: self = .lostConnectivityTransmissionStatus
    case 30: self = .failedDisallowedMedium
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownAttachmentTransmissionStatus: return 0
    case .completeAttachmentTransmissionStatus: return 1
    case .canceledAttachmentTransmissionStatus: return 2
    case .failedAttachmentTransmissionStatus: return 3
    case .rejectedAttachment: return 4
    case .timedOutAttachment: return 5
    case .awaitingRemoteAcceptanceFailedAttachment: return 6
    case .notEnoughSpaceAttachment: return 7
    case .failedNoTransferUpdateCallback: return 8
    case .mediaUnavailableAttachment: return 9
    case .unsupportedAttachmentTypeAttachment: return 10
    case .noAttachmentFound: return 11
    case .failedNoShareTargetEndpoint: return 12
    case .failedPairedKeyhandshake: return 13
    case .failedNullConnection: return 14
    case .failedNoPayload: return 15
    case .failedWriteIntroduction: return 16
    case .failedUnknownRemoteResponse: return 17
    case .failedNullConnectionInitOutgoing: return 18
    case .failedNullConnectionDisconnected: return 19
    case .failedNullConnectionLostConnectivity: return 20
    case .failedNullConnectionFailure: return 21
    case .rejectedAttachmentTransmissionStatus: return 22
    case .timedOutAttachmentTransmissionStatus: return 23
    case .notEnoughSpaceAttachmentTransmissionStatus: return 24
    case .unsupportedAttachmentTypeAttachmentTransmissionStatus: return 25
    case .failedUnknownRemoteResponseTransmissionStatus: return 26
    case .noResponseFrameConnectionClosedLostConnectivityTransmissionStatus: return 27
    case .noResponseFrameConnectionClosedTransmissionStatus: return 28
    case .lostConnectivityTransmissionStatus: return 29
    case .failedDisallowedMedium: return 30
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_AttachmentTransmissionStatus: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// Generic result status of NearbyConnections API calls.
enum Location_Nearby_Proto_Sharing_ConnectionLayerStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// No status is available
  case unknown // = 0

  /// The operation was successful.
  case success // = 1

  /// The operation failed, without any more information.
  case error // = 2

  /// The app called an API method out of order (i.e. another method is expected
  /// to be called first).
  case outOfOrderApiCall // = 3

  /// The app already has active operations (advertising, discovering, or
  /// connected to other devices) with another Strategy. Stop these operations on
  /// the current Strategy before trying to advertise or discover with a new
  /// Strategy.
  case alreadyHaveActiveStrategy // = 4

  /// The app is already advertising; call StopAdvertising() before trying to
  /// advertise again.
  case alreadyAdvertising // = 5

  /// The app is already discovering; call StopDiscovery() before trying to
  /// discover again.
  case alreadyDiscovering // = 6

  /// NC is already listening for incoming connections from remote endpoints.
  case alreadyListening // = 7

  /// An attempt to read from/write to a connected remote endpoint failed. If
  /// this occurs repeatedly, consider invoking DisconnectFromEndpoint().
  case endPointIoError // = 8

  /// An attempt to interact with a remote endpoint failed because it's unknown
  /// to us -- it's either an endpoint that was never discovered, or an endpoint
  /// that never connected to us (both of which are indicative of bad input from
  /// the client app).
  case endPointUnknown // = 9

  /// The remote endpoint rejected the connection request.
  case connectionRejected // = 10

  /// The app is already connected to the specified endpoint. Multiple
  /// connections to a remote endpoint cannot be maintained simultaneously.
  case alreadyConnectedToEndPoint // = 11

  /// The remote endpoint is not connected; messages cannot be sent to it.
  case notConnectedToEndPoint // = 12

  /// There was an error trying to use the device's Bluetooth capabilities.
  case bluetoothError // = 13

  /// There was an error trying to use the device's Bluetooth Low Energy
  /// capabilities.
  case bleError // = 14

  /// There was an error trying to use the device's Wi-Fi capabilities.
  case wifiLanError // = 15

  /// An attempt to interact with an in-flight Payload failed because it's
  /// unknown to us.
  case payloadUnknown // = 16

  /// The connection was reset
  case reset // = 17

  /// The connection timed out
  case timeout // = 18

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .success
    case 2: self = .error
    case 3: self = .outOfOrderApiCall
    case 4: self = .alreadyHaveActiveStrategy
    case 5: self = .alreadyAdvertising
    case 6: self = .alreadyDiscovering
    case 7: self = .alreadyListening
    case 8: self = .endPointIoError
    case 9: self = .endPointUnknown
    case 10: self = .connectionRejected
    case 11: self = .alreadyConnectedToEndPoint
    case 12: self = .notConnectedToEndPoint
    case 13: self = .bluetoothError
    case 14: self = .bleError
    case 15: self = .wifiLanError
    case 16: self = .payloadUnknown
    case 17: self = .reset
    case 18: self = .timeout
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .success: return 1
    case .error: return 2
    case .outOfOrderApiCall: return 3
    case .alreadyHaveActiveStrategy: return 4
    case .alreadyAdvertising: return 5
    case .alreadyDiscovering: return 6
    case .alreadyListening: return 7
    case .endPointIoError: return 8
    case .endPointUnknown: return 9
    case .connectionRejected: return 10
    case .alreadyConnectedToEndPoint: return 11
    case .notConnectedToEndPoint: return 12
    case .bluetoothError: return 13
    case .bleError: return 14
    case .wifiLanError: return 15
    case .payloadUnknown: return 16
    case .reset: return 17
    case .timeout: return 18
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_ConnectionLayerStatus: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// The status of processing attachments after receiver received payloads
/// successfully.
enum Location_Nearby_Proto_Sharing_ProcessReceivedAttachmentsStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case processingStatusUnknown // = 0
  case processingStatusCompleteProcessingAttachments // = 1
  case processingStatusFailedMovingFiles // = 2
  case processingStatusFailedReceivingApk // = 3
  case processingStatusFailedReceivingText // = 4
  case processingStatusFailedReceivingWifiCredentials // = 5

  init() {
    self = .processingStatusUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .processingStatusUnknown
    case 1: self = .processingStatusCompleteProcessingAttachments
    case 2: self = .processingStatusFailedMovingFiles
    case 3: self = .processingStatusFailedReceivingApk
    case 4: self = .processingStatusFailedReceivingText
    case 5: self = .processingStatusFailedReceivingWifiCredentials
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .processingStatusUnknown: return 0
    case .processingStatusCompleteProcessingAttachments: return 1
    case .processingStatusFailedMovingFiles: return 2
    case .processingStatusFailedReceivingApk: return 3
    case .processingStatusFailedReceivingText: return 4
    case .processingStatusFailedReceivingWifiCredentials: return 5
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_ProcessReceivedAttachmentsStatus: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// The status of advertising and discovering sessions. Used by
/// SCAN_FOR_SHARE_TARGETS and ADVERTISE_DEVICE_PRESENCE.
enum Location_Nearby_Proto_Sharing_SessionStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownSessionStatus // = 0
  case succeededSessionStatus // = 1

  /// TODO: b/341782941 - FAILED_SESSION_STATUS occurs when the status of
  /// advertising or discovering sessions is not successful. It can be
  /// due to STATUS_INTERNAL_ERROR, STATUS_INTERRUPTION, STATUS_CANCELLED.
  /// More session statuses should be logged to determine the status.
  case failedSessionStatus // = 2

  init() {
    self = .unknownSessionStatus
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownSessionStatus
    case 1: self = .succeededSessionStatus
    case 2: self = .failedSessionStatus
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownSessionStatus: return 0
    case .succeededSessionStatus: return 1
    case .failedSessionStatus: return 2
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_SessionStatus: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// User's response to introductions.
enum Location_Nearby_Proto_Sharing_ResponseToIntroduction: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownResponseToIntroduction // = 0
  case acceptIntroduction // = 1
  case rejectIntroduction // = 2
  case failIntroduction // = 3

  init() {
    self = .unknownResponseToIntroduction
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownResponseToIntroduction
    case 1: self = .acceptIntroduction
    case 2: self = .rejectIntroduction
    case 3: self = .failIntroduction
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownResponseToIntroduction: return 0
    case .acceptIntroduction: return 1
    case .rejectIntroduction: return 2
    case .failIntroduction: return 3
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_ResponseToIntroduction: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// TODO(fdi): may eventually include desktop, etc.
/// The type of a remote device.
enum Location_Nearby_Proto_Sharing_DeviceType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownDeviceType // = 0
  case phone // = 1
  case tablet // = 2
  case laptop // = 3
  case car // = 4
  case foldable // = 5
  case xr // = 6

  init() {
    self = .unknownDeviceType
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownDeviceType
    case 1: self = .phone
    case 2: self = .tablet
    case 3: self = .laptop
    case 4: self = .car
    case 5: self = .foldable
    case 6: self = .xr
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownDeviceType: return 0
    case .phone: return 1
    case .tablet: return 2
    case .laptop: return 3
    case .car: return 4
    case .foldable: return 5
    case .xr: return 6
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_DeviceType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// TODO(fdi): may eventually include windows, iOS, etc.
/// The OS type of a remote device.
enum Location_Nearby_Proto_Sharing_OSType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownOsType // = 0
  case android // = 1
  case chromeOs // = 2
  case ios // = 3
  case windows // = 4
  case macos // = 5

  init() {
    self = .unknownOsType
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownOsType
    case 1: self = .android
    case 2: self = .chromeOs
    case 3: self = .ios
    case 4: self = .windows
    case 5: self = .macos
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownOsType: return 0
    case .android: return 1
    case .chromeOs: return 2
    case .ios: return 3
    case .windows: return 4
    case .macos: return 5
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_OSType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// Relationship of remote device to sender device.
enum Location_Nearby_Proto_Sharing_DeviceRelationship: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownDeviceRelationship // = 0

  /// The remote device belongs to the same owner as sender device.
  case isSelf // = 1

  /// The remote device is a contact of sender.
  case isContact // = 2

  /// The remote device is a stranger.
  case isStranger // = 3

  init() {
    self = .unknownDeviceRelationship
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownDeviceRelationship
    case 1: self = .isSelf
    case 2: self = .isContact
    case 3: self = .isStranger
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownDeviceRelationship: return 0
    case .isSelf: return 1
    case .isContact: return 2
    case .isStranger: return 3
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_DeviceRelationship: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// The device sources of the clearcut log.
enum Location_Nearby_Proto_Sharing_LogSource: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecifiedSource // = 0

  /// Represents the devices in Nearby labs.
  case labDevices // = 1

  /// Represents the devices tested by Nearby engs, in the long term can include
  /// any devices with newest feature flags.
  case internalDevices // = 2

  /// Represents the devices testing our in-development features before they're
  /// released to the greater public.
  case betaTesterDevices // = 3

  /// Represents the OEM partners (like Samsung) that we're working with to
  /// verify functionality on their devices.
  case oemDevices // = 4

  /// Represents the device for debugging.
  case debugDevices // = 5

  /// Represents the device for Nearby Module Food.
  case nearbyModuleFoodDevices // = 6

  /// Represents the device for BeTo Team Food.
  case betoDogfoodDevices // = 7

  /// Represents the device for Nearby dog Food.
  case nearbyDogfoodDevices // = 8

  /// Represents the device for Nearby Team Food.
  case nearbyTeamfoodDevices // = 9

  init() {
    self = .unspecifiedSource
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecifiedSource
    case 1: self = .labDevices
    case 2: self = .internalDevices
    case 3: self = .betaTesterDevices
    case 4: self = .oemDevices
    case 5: self = .debugDevices
    case 6: self = .nearbyModuleFoodDevices
    case 7: self = .betoDogfoodDevices
    case 8: self = .nearbyDogfoodDevices
    case 9: self = .nearbyTeamfoodDevices
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecifiedSource: return 0
    case .labDevices: return 1
    case .internalDevices: return 2
    case .betaTesterDevices: return 3
    case .oemDevices: return 4
    case .debugDevices: return 5
    case .nearbyModuleFoodDevices: return 6
    case .betoDogfoodDevices: return 7
    case .nearbyDogfoodDevices: return 8
    case .nearbyTeamfoodDevices: return 9
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_LogSource: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// The Fast Share server action name.
enum Location_Nearby_Proto_Sharing_ServerActionName: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownServerAction // = 0
  case uploadCertificates // = 1
  case downloadCertificates // = 2
  case checkReachability // = 3
  case uploadContacts // = 4
  case updateDeviceName // = 5
  case uploadSenderCertificates // = 6
  case downloadSenderCertificates // = 7
  case uploadContactsAndCertificates // = 8
  case listReachablePhoneNumbers // = 9
  case listMyDevices // = 10
  case listContactPeople // = 11

  /// used for analytics logger to record action name.
  case downloadCertificatesInfo // = 12

  init() {
    self = .unknownServerAction
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownServerAction
    case 1: self = .uploadCertificates
    case 2: self = .downloadCertificates
    case 3: self = .checkReachability
    case 4: self = .uploadContacts
    case 5: self = .updateDeviceName
    case 6: self = .uploadSenderCertificates
    case 7: self = .downloadSenderCertificates
    case 8: self = .uploadContactsAndCertificates
    case 9: self = .listReachablePhoneNumbers
    case 10: self = .listMyDevices
    case 11: self = .listContactPeople
    case 12: self = .downloadCertificatesInfo
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownServerAction: return 0
    case .uploadCertificates: return 1
    case .downloadCertificates: return 2
    case .checkReachability: return 3
    case .uploadContacts: return 4
    case .updateDeviceName: return 5
    case .uploadSenderCertificates: return 6
    case .downloadSenderCertificates: return 7
    case .uploadContactsAndCertificates: return 8
    case .listReachablePhoneNumbers: return 9
    case .listMyDevices: return 10
    case .listContactPeople: return 11
    case .downloadCertificatesInfo: return 12
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_ServerActionName: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// The Fast Share server response state.
enum Location_Nearby_Proto_Sharing_ServerResponseState: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownServerResponseState // = 0
  case serverResponseSuccess // = 1
  case serverResponseUnknownFailure // = 2

  /// For StatusException.
  case serverResponseStatusOtherFailure // = 3
  case serverResponseStatusDeadlineExceeded // = 4
  case serverResponseStatusPermissionDenied // = 5
  case serverResponseStatusUnavailable // = 6
  case serverResponseStatusUnauthenticated // = 7
  case serverResponseStatusInvalidArgument // = 9

  /// For GoogleAuthException.
  case serverResponseGoogleAuthFailure // = 8

  /// For Internet connect status.
  case serverResponseNotConnectedToInternet // = 10

  init() {
    self = .unknownServerResponseState
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownServerResponseState
    case 1: self = .serverResponseSuccess
    case 2: self = .serverResponseUnknownFailure
    case 3: self = .serverResponseStatusOtherFailure
    case 4: self = .serverResponseStatusDeadlineExceeded
    case 5: self = .serverResponseStatusPermissionDenied
    case 6: self = .serverResponseStatusUnavailable
    case 7: self = .serverResponseStatusUnauthenticated
    case 8: self = .serverResponseGoogleAuthFailure
    case 9: self = .serverResponseStatusInvalidArgument
    case 10: self = .serverResponseNotConnectedToInternet
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownServerResponseState: return 0
    case .serverResponseSuccess: return 1
    case .serverResponseUnknownFailure: return 2
    case .serverResponseStatusOtherFailure: return 3
    case .serverResponseStatusDeadlineExceeded: return 4
    case .serverResponseStatusPermissionDenied: return 5
    case .serverResponseStatusUnavailable: return 6
    case .serverResponseStatusUnauthenticated: return 7
    case .serverResponseGoogleAuthFailure: return 8
    case .serverResponseStatusInvalidArgument: return 9
    case .serverResponseNotConnectedToInternet: return 10
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_ServerResponseState: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// The purpose of requesting the server request.
enum Location_Nearby_Proto_Sharing_SyncPurpose: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0

  /// When NearbySharingChimeraService#sync() is called.
  case onDemandSync // = 1

  /// Requested by chime notification.
  case chimeNotification // = 2

  /// For reqular daily sync.
  case dailySync // = 3

  /// Wen a device opts into Nearby Share.
  case optInFirstSync // = 4

  /// Requested when Nearby Share automatically enables a device that shares
  /// a single account that has already opted in on another device.
  case checkDefaultOptIn // = 5

  /// When a device enables Nearby Share.
  case nearbyShareEnabled // = 6

  /// When a device is in fast init advertising.
  case syncAtFastInit // = 7

  /// When device start discovery.
  case syncAtDiscovery // = 8

  /// When device tries to load valid private certificate.
  case syncAtLoadPrivateCertificate // = 9

  /// When device start advertiseement.
  case syncAtAdvertisement // = 10

  /// When device contacts list changes.
  case contactListChange // = 11

  /// When showing the C11 banner in Neary Share setting.
  case showC11NView // = 12

  /// For regular check contact reachability.
  case regularCheckContactReachability // = 13

  /// When selected contacts list changes in visibility setting.
  case visibilitySelectedContactChange // = 14

  /// When switching account.
  case accountChange // = 15

  /// When regenerate certificates
  case regenerateCertificates // = 16

  /// When Device Contacts consent changes
  case deviceContactsConsentChange // = 17

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .onDemandSync
    case 2: self = .chimeNotification
    case 3: self = .dailySync
    case 4: self = .optInFirstSync
    case 5: self = .checkDefaultOptIn
    case 6: self = .nearbyShareEnabled
    case 7: self = .syncAtFastInit
    case 8: self = .syncAtDiscovery
    case 9: self = .syncAtLoadPrivateCertificate
    case 10: self = .syncAtAdvertisement
    case 11: self = .contactListChange
    case 12: self = .showC11NView
    case 13: self = .regularCheckContactReachability
    case 14: self = .visibilitySelectedContactChange
    case 15: self = .accountChange
    case 16: self = .regenerateCertificates
    case 17: self = .deviceContactsConsentChange
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .onDemandSync: return 1
    case .chimeNotification: return 2
    case .dailySync: return 3
    case .optInFirstSync: return 4
    case .checkDefaultOptIn: return 5
    case .nearbyShareEnabled: return 6
    case .syncAtFastInit: return 7
    case .syncAtDiscovery: return 8
    case .syncAtLoadPrivateCertificate: return 9
    case .syncAtAdvertisement: return 10
    case .contactListChange: return 11
    case .showC11NView: return 12
    case .regularCheckContactReachability: return 13
    case .visibilitySelectedContactChange: return 14
    case .accountChange: return 15
    case .regenerateCertificates: return 16
    case .deviceContactsConsentChange: return 17
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_SyncPurpose: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// The device role to trigger the server request.
enum Location_Nearby_Proto_Sharing_ClientRole: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case sender // = 1
  case receiver // = 2

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .sender
    case 2: self = .receiver
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .sender: return 1
    case .receiver: return 2
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_ClientRole: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// The type of Nearby Sharing scanning.
enum Location_Nearby_Proto_Sharing_ScanType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownScanType // = 0
  case foregroundScan // = 1
  case foregroundRetryScan // = 2
  case directShareScan // = 3
  case backgroundScan // = 4

  init() {
    self = .unknownScanType
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownScanType
    case 1: self = .foregroundScan
    case 2: self = .foregroundRetryScan
    case 3: self = .directShareScan
    case 4: self = .backgroundScan
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownScanType: return 0
    case .foregroundScan: return 1
    case .foregroundRetryScan: return 2
    case .directShareScan: return 3
    case .backgroundScan: return 4
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_ScanType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// The type of parsing endpoint id failed type.
enum Location_Nearby_Proto_Sharing_ParsingFailedType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case failedUnknownType // = 0

  /// NULL advertisement is returned due to sender failing to parse advertisement
  /// from endpointInfo byte stream from receiver advertisement.
  case failedParseAdvertisement // = 1

  /// NULL shareTarget is returned due to sender failing to create shareTarget
  /// from a valid parsed advertisement stemming from issues in certificates, QR
  /// code tokens or device names.
  case failedConvertShareTarget // = 2

  init() {
    self = .failedUnknownType
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .failedUnknownType
    case 1: self = .failedParseAdvertisement
    case 2: self = .failedConvertShareTarget
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .failedUnknownType: return 0
    case .failedParseAdvertisement: return 1
    case .failedConvertShareTarget: return 2
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_ParsingFailedType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// The Nearby Sharing advertising mode.
enum Location_Nearby_Proto_Sharing_AdvertisingMode: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownAdvertisingMode // = 0
  case screenOffAdvertisingMode // = 1
  case backgroundAdvertisingMode // = 2
  case midgroundAdvertisingMode // = 3
  case foregroundAdvertisingMode // = 4
  case suspendedAdvertisingMode // = 5

  init() {
    self = .unknownAdvertisingMode
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownAdvertisingMode
    case 1: self = .screenOffAdvertisingMode
    case 2: self = .backgroundAdvertisingMode
    case 3: self = .midgroundAdvertisingMode
    case 4: self = .foregroundAdvertisingMode
    case 5: self = .suspendedAdvertisingMode
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownAdvertisingMode: return 0
    case .screenOffAdvertisingMode: return 1
    case .backgroundAdvertisingMode: return 2
    case .midgroundAdvertisingMode: return 3
    case .foregroundAdvertisingMode: return 4
    case .suspendedAdvertisingMode: return 5
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_AdvertisingMode: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// The Nearby Sharing discovery mode.
enum Location_Nearby_Proto_Sharing_DiscoveryMode: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownDiscoveryMode // = 0
  case screenOffDiscoveryMode // = 1
  case backgroundDiscoveryMode // = 2
  case midgroundDiscoveryMode // = 3
  case foregroundDiscoveryMode // = 4
  case suspendedDiscoveryMode // = 5

  init() {
    self = .unknownDiscoveryMode
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownDiscoveryMode
    case 1: self = .screenOffDiscoveryMode
    case 2: self = .backgroundDiscoveryMode
    case 3: self = .midgroundDiscoveryMode
    case 4: self = .foregroundDiscoveryMode
    case 5: self = .suspendedDiscoveryMode
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownDiscoveryMode: return 0
    case .screenOffDiscoveryMode: return 1
    case .backgroundDiscoveryMode: return 2
    case .midgroundDiscoveryMode: return 3
    case .foregroundDiscoveryMode: return 4
    case .suspendedDiscoveryMode: return 5
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_DiscoveryMode: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// The class name of chimera activity.
enum Location_Nearby_Proto_Sharing_ActivityName: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownActivity // = 0
  case shareSheetActivity // = 1
  case settingsActivity // = 2
  case receiveSurfaceActivity // = 3
  case setupActivity // = 4
  case deviceVisibilityActivity // = 5
  case consentsActivity // = 6
  case setDeviceNameDialog // = 7
  case setDataUsageDialog // = 8
  case quickSettingsActivity // = 9
  case remoteCopyShareSheetActivity // = 10
  case setupWizardActivity // = 11
  case settingsReviewActivity // = 12

  init() {
    self = .unknownActivity
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownActivity
    case 1: self = .shareSheetActivity
    case 2: self = .settingsActivity
    case 3: self = .receiveSurfaceActivity
    case 4: self = .setupActivity
    case 5: self = .deviceVisibilityActivity
    case 6: self = .consentsActivity
    case 7: self = .setDeviceNameDialog
    case 8: self = .setDataUsageDialog
    case 9: self = .quickSettingsActivity
    case 10: self = .remoteCopyShareSheetActivity
    case 11: self = .setupWizardActivity
    case 12: self = .settingsReviewActivity
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownActivity: return 0
    case .shareSheetActivity: return 1
    case .settingsActivity: return 2
    case .receiveSurfaceActivity: return 3
    case .setupActivity: return 4
    case .deviceVisibilityActivity: return 5
    case .consentsActivity: return 6
    case .setDeviceNameDialog: return 7
    case .setDataUsageDialog: return 8
    case .quickSettingsActivity: return 9
    case .remoteCopyShareSheetActivity: return 10
    case .setupWizardActivity: return 11
    case .settingsReviewActivity: return 12
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_ActivityName: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// The type of consent page user launches.
enum Location_Nearby_Proto_Sharing_ConsentType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0

  /// launch Constellation consent page.
  case c11N // = 1

  /// launch device contact consent page.
  case deviceContact // = 2

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .c11N
    case 2: self = .deviceContact
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .c11N: return 1
    case .deviceContact: return 2
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_ConsentType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum Location_Nearby_Proto_Sharing_ConsentAcceptanceStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case consentUnknownAcceptStatus // = 0
  case consentAccepted // = 1
  case consentDeclined // = 2

  /// unable to enable consent.
  case consentUnableToEnable // = 3

  init() {
    self = .consentUnknownAcceptStatus
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .consentUnknownAcceptStatus
    case 1: self = .consentAccepted
    case 2: self = .consentDeclined
    case 3: self = .consentUnableToEnable
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .consentUnknownAcceptStatus: return 0
    case .consentAccepted: return 1
    case .consentDeclined: return 2
    case .consentUnableToEnable: return 3
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_ConsentAcceptanceStatus: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum Location_Nearby_Proto_Sharing_ApkSource: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownApkSource // = 0
  case apkFromSdCard // = 1
  case installedApp // = 2

  init() {
    self = .unknownApkSource
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownApkSource
    case 1: self = .apkFromSdCard
    case 2: self = .installedApp
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownApkSource: return 0
    case .apkFromSdCard: return 1
    case .installedApp: return 2
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_ApkSource: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// The Installation status of APK.
enum Location_Nearby_Proto_Sharing_InstallAPKStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownInstallApkStatus // = 0
  case failInstallation // = 1
  case successInstallation // = 2

  init() {
    self = .unknownInstallApkStatus
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownInstallApkStatus
    case 1: self = .failInstallation
    case 2: self = .successInstallation
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownInstallApkStatus: return 0
    case .failInstallation: return 1
    case .successInstallation: return 2
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_InstallAPKStatus: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// The verification status of APK.
enum Location_Nearby_Proto_Sharing_VerifyAPKStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownVerifyApkStatus // = 0
  case notInstallable // = 1
  case installable // = 2
  case alreadyInstalled // = 3

  init() {
    self = .unknownVerifyApkStatus
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownVerifyApkStatus
    case 1: self = .notInstallable
    case 2: self = .installable
    case 3: self = .alreadyInstalled
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownVerifyApkStatus: return 0
    case .notInstallable: return 1
    case .installable: return 2
    case .alreadyInstalled: return 3
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_VerifyAPKStatus: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum Location_Nearby_Proto_Sharing_ShowNotificationStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownShowNotificationStatus // = 0
  case show // = 1
  case notShow // = 2

  init() {
    self = .unknownShowNotificationStatus
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownShowNotificationStatus
    case 1: self = .show
    case 2: self = .notShow
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownShowNotificationStatus: return 0
    case .show: return 1
    case .notShow: return 2
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_ShowNotificationStatus: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum Location_Nearby_Proto_Sharing_PermissionRequestResult: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case permissionUnknownRequestResult // = 0
  case permissionGranted // = 1
  case permissionRejected // = 2
  case permissionUnableToGrant // = 3

  init() {
    self = .permissionUnknownRequestResult
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .permissionUnknownRequestResult
    case 1: self = .permissionGranted
    case 2: self = .permissionRejected
    case 3: self = .permissionUnableToGrant
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .permissionUnknownRequestResult: return 0
    case .permissionGranted: return 1
    case .permissionRejected: return 2
    case .permissionUnableToGrant: return 3
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_PermissionRequestResult: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum Location_Nearby_Proto_Sharing_PermissionRequestType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case permissionUnknownType // = 0
  case permissionAirplaneModeOff // = 1
  case permissionWifi // = 2
  case permissionBluetooth // = 3
  case permissionLocation // = 4
  case permissionWifiHotspot // = 5

  init() {
    self = .permissionUnknownType
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .permissionUnknownType
    case 1: self = .permissionAirplaneModeOff
    case 2: self = .permissionWifi
    case 3: self = .permissionBluetooth
    case 4: self = .permissionLocation
    case 5: self = .permissionWifiHotspot
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .permissionUnknownType: return 0
    case .permissionAirplaneModeOff: return 1
    case .permissionWifi: return 2
    case .permissionBluetooth: return 3
    case .permissionLocation: return 4
    case .permissionWifiHotspot: return 5
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_PermissionRequestType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum Location_Nearby_Proto_Sharing_SharingUseCase: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case useCaseUnknown // = 0
  case useCaseNearbyShare // = 1
  case useCaseRemoteCopyPaste // = 2
  case useCaseWifiCredential // = 3
  case useCaseAppShare // = 4
  case useCaseQuickSettingFileShare // = 5
  case useCaseSetupWizard // = 6

  /// Deprecated. QR code is an addition to existing use cases rather than being
  /// a separate use case.
  case useCaseNearbyShareWithQrCode // = 7

  /// The user was redirected from Bluetooth sharing UI to Nearby Share
  case useCaseRedirectedFromBluetoothShare // = 8

  init() {
    self = .useCaseUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .useCaseUnknown
    case 1: self = .useCaseNearbyShare
    case 2: self = .useCaseRemoteCopyPaste
    case 3: self = .useCaseWifiCredential
    case 4: self = .useCaseAppShare
    case 5: self = .useCaseQuickSettingFileShare
    case 6: self = .useCaseSetupWizard
    case 7: self = .useCaseNearbyShareWithQrCode
    case 8: self = .useCaseRedirectedFromBluetoothShare
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .useCaseUnknown: return 0
    case .useCaseNearbyShare: return 1
    case .useCaseRemoteCopyPaste: return 2
    case .useCaseWifiCredential: return 3
    case .useCaseAppShare: return 4
    case .useCaseQuickSettingFileShare: return 5
    case .useCaseSetupWizard: return 6
    case .useCaseNearbyShareWithQrCode: return 7
    case .useCaseRedirectedFromBluetoothShare: return 8
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_SharingUseCase: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// Used only for Windows App now.
enum Location_Nearby_Proto_Sharing_AppCrashReason: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_AppCrashReason: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// Thes source where the attachemnt comes from. It can be an action, app name,
/// etc. The first 6 source types are being used as FileSenderType in Nearby
/// Share Windows app.
enum Location_Nearby_Proto_Sharing_AttachmentSourceType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case attachmentSourceUnknown // = 0
  case attachmentSourceContextMenu // = 1
  case attachmentSourceDragAndDrop // = 2
  case attachmentSourceSelectFilesButton // = 3
  case attachmentSourcePaste // = 4
  case attachmentSourceSelectFoldersButton // = 5
  case attachmentSourceShareActivation // = 6

  init() {
    self = .attachmentSourceUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .attachmentSourceUnknown
    case 1: self = .attachmentSourceContextMenu
    case 2: self = .attachmentSourceDragAndDrop
    case 3: self = .attachmentSourceSelectFilesButton
    case 4: self = .attachmentSourcePaste
    case 5: self = .attachmentSourceSelectFoldersButton
    case 6: self = .attachmentSourceShareActivation
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .attachmentSourceUnknown: return 0
    case .attachmentSourceContextMenu: return 1
    case .attachmentSourceDragAndDrop: return 2
    case .attachmentSourceSelectFilesButton: return 3
    case .attachmentSourcePaste: return 4
    case .attachmentSourceSelectFoldersButton: return 5
    case .attachmentSourceShareActivation: return 6
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_AttachmentSourceType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// The action to interact with preferences.
/// Used only for Windows App now.
enum Location_Nearby_Proto_Sharing_PreferencesAction: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case noAction // = 1

  /// Primary actions/functions towards preferences
  case loadPreferences // = 2
  case savePreferencess // = 3
  case attemptLoad // = 4
  case restoreFromBackup // = 5

  /// Other actions within the 4 actions above
  case createPreferencesPath // = 6
  case makePreferencesBackupFile // = 7
  case checkIfPreferencesPathExists // = 8
  case checkIfPreferencesInputStreamStatus // = 9
  case checkIfPreferencesFileIsCorrupted // = 10
  case checkIfPreferencesBackupFileExists // = 11

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .noAction
    case 2: self = .loadPreferences
    case 3: self = .savePreferencess
    case 4: self = .attemptLoad
    case 5: self = .restoreFromBackup
    case 6: self = .createPreferencesPath
    case 7: self = .makePreferencesBackupFile
    case 8: self = .checkIfPreferencesPathExists
    case 9: self = .checkIfPreferencesInputStreamStatus
    case 10: self = .checkIfPreferencesFileIsCorrupted
    case 11: self = .checkIfPreferencesBackupFileExists
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .noAction: return 1
    case .loadPreferences: return 2
    case .savePreferencess: return 3
    case .attemptLoad: return 4
    case .restoreFromBackup: return 5
    case .createPreferencesPath: return 6
    case .makePreferencesBackupFile: return 7
    case .checkIfPreferencesPathExists: return 8
    case .checkIfPreferencesInputStreamStatus: return 9
    case .checkIfPreferencesFileIsCorrupted: return 10
    case .checkIfPreferencesBackupFileExists: return 11
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_PreferencesAction: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// The status of the action to interact with preferences.
/// Used only for Windows App now.
enum Location_Nearby_Proto_Sharing_PreferencesActionStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case success // = 1
  case fail // = 2

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .success
    case 2: self = .fail
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .success: return 1
    case .fail: return 2
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_PreferencesActionStatus: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

///* The distance of the found nearby fast init advertisement. 
enum Location_Nearby_Proto_Sharing_FastInitState: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case fastInitUnknownState // = 0

  /// A device was found in close proximity.
  /// distance < fast_init_distance_close_centimeters(50 cm)
  case fastInitCloseState // = 1

  /// A device was found in far proximity.
  /// distance < fast_init_distance_close_centimeters(10 m)
  case fastInitFarState // = 2

  /// No devices have been found nearby. The default state.
  case fastInitLostState // = 3

  init() {
    self = .fastInitUnknownState
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .fastInitUnknownState
    case 1: self = .fastInitCloseState
    case 2: self = .fastInitFarState
    case 3: self = .fastInitLostState
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .fastInitUnknownState: return 0
    case .fastInitCloseState: return 1
    case .fastInitFarState: return 2
    case .fastInitLostState: return 3
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_FastInitState: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

///* The type of FastInit advertisement. 
enum Location_Nearby_Proto_Sharing_FastInitType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case fastInitUnknownType // = 0

  /// Show HUN to notify the user.
  case fastInitNotifyType // = 1

  /// Not notify the user.
  case fastInitSilentType // = 2

  init() {
    self = .fastInitUnknownType
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .fastInitUnknownType
    case 1: self = .fastInitNotifyType
    case 2: self = .fastInitSilentType
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .fastInitUnknownType: return 0
    case .fastInitNotifyType: return 1
    case .fastInitSilentType: return 2
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_FastInitType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

///* The type of desktop notification event. 
enum Location_Nearby_Proto_Sharing_DesktopNotification: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case connecting // = 1
  case progress // = 2
  case accept // = 3
  case received // = 4
  case error // = 5

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .connecting
    case 2: self = .progress
    case 3: self = .accept
    case 4: self = .received
    case 5: self = .error
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .connecting: return 1
    case .progress: return 2
    case .accept: return 3
    case .received: return 4
    case .error: return 5
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_DesktopNotification: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum Location_Nearby_Proto_Sharing_DesktopTransferEventType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0

  /// Receive attachments.
  case desktopTransferEventReceiveTypeAccept // = 1
  case desktopTransferEventReceiveTypeProgress // = 2
  case desktopTransferEventReceiveTypeReceived // = 3
  case desktopTransferEventReceiveTypeError // = 4

  /// Send attachments.
  case desktopTransferEventSendTypeStart // = 5
  case desktopTransferEventSendTypeSelectADevice // = 6
  case desktopTransferEventSendTypeProgress // = 7
  case desktopTransferEventSendTypeSent // = 8
  case desktopTransferEventSendTypeError // = 9

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .desktopTransferEventReceiveTypeAccept
    case 2: self = .desktopTransferEventReceiveTypeProgress
    case 3: self = .desktopTransferEventReceiveTypeReceived
    case 4: self = .desktopTransferEventReceiveTypeError
    case 5: self = .desktopTransferEventSendTypeStart
    case 6: self = .desktopTransferEventSendTypeSelectADevice
    case 7: self = .desktopTransferEventSendTypeProgress
    case 8: self = .desktopTransferEventSendTypeSent
    case 9: self = .desktopTransferEventSendTypeError
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .desktopTransferEventReceiveTypeAccept: return 1
    case .desktopTransferEventReceiveTypeProgress: return 2
    case .desktopTransferEventReceiveTypeReceived: return 3
    case .desktopTransferEventReceiveTypeError: return 4
    case .desktopTransferEventSendTypeStart: return 5
    case .desktopTransferEventSendTypeSelectADevice: return 6
    case .desktopTransferEventSendTypeProgress: return 7
    case .desktopTransferEventSendTypeSent: return 8
    case .desktopTransferEventSendTypeError: return 9
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_DesktopTransferEventType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum Location_Nearby_Proto_Sharing_DecryptCertificateFailureStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case decryptCertUnknownFailure // = 0
  case decryptCertNoSuchAlgorithmFailure // = 1
  case decryptCertNoSuchPaddingFailure // = 2
  case decryptCertInvalidKeyFailure // = 3
  case decryptCertInvalidAlgorithmParameterFailure // = 4
  case decryptCertIllegalBlockSizeFailure // = 5
  case decryptCertBadPaddingFailure // = 6

  init() {
    self = .decryptCertUnknownFailure
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .decryptCertUnknownFailure
    case 1: self = .decryptCertNoSuchAlgorithmFailure
    case 2: self = .decryptCertNoSuchPaddingFailure
    case 3: self = .decryptCertInvalidKeyFailure
    case 4: self = .decryptCertInvalidAlgorithmParameterFailure
    case 5: self = .decryptCertIllegalBlockSizeFailure
    case 6: self = .decryptCertBadPaddingFailure
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .decryptCertUnknownFailure: return 0
    case .decryptCertNoSuchAlgorithmFailure: return 1
    case .decryptCertNoSuchPaddingFailure: return 2
    case .decryptCertInvalidKeyFailure: return 3
    case .decryptCertInvalidAlgorithmParameterFailure: return 4
    case .decryptCertIllegalBlockSizeFailure: return 5
    case .decryptCertBadPaddingFailure: return 6
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_DecryptCertificateFailureStatus: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// Refer to go/qs-contacts-consent-2024 for the detail.
enum Location_Nearby_Proto_Sharing_ContactAccess: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case noContactUploaded // = 1
  case onlyUploadGoogleContact // = 2
  case uploadContactForDeviceContactConsent // = 3
  case uploadContactForQuickShareConsent // = 4

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .noContactUploaded
    case 2: self = .onlyUploadGoogleContact
    case 3: self = .uploadContactForDeviceContactConsent
    case 4: self = .uploadContactForQuickShareConsent
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .noContactUploaded: return 1
    case .onlyUploadGoogleContact: return 2
    case .uploadContactForDeviceContactConsent: return 3
    case .uploadContactForQuickShareConsent: return 4
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_ContactAccess: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// Refer to go/qs-contacts-consent-2024 for the detail.
enum Location_Nearby_Proto_Sharing_IdentityVerification: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case noPhoneNumberVerified // = 1
  case phoneNumberVerifiedNotLinkedToGaia // = 2
  case phoneNumberVerifiedLinkedToQsGaia // = 3

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .noPhoneNumberVerified
    case 2: self = .phoneNumberVerifiedNotLinkedToGaia
    case 3: self = .phoneNumberVerifiedLinkedToQsGaia
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .noPhoneNumberVerified: return 1
    case .phoneNumberVerifiedNotLinkedToGaia: return 2
    case .phoneNumberVerifiedLinkedToQsGaia: return 3
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_IdentityVerification: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum Location_Nearby_Proto_Sharing_ButtonStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case clickAccept // = 1
  case clickReject // = 2
  case ignore // = 3

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .clickAccept
    case 2: self = .clickReject
    case 3: self = .ignore
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .clickAccept: return 1
    case .clickReject: return 2
    case .ignore: return 3
    }
  }

}

#if swift(>=4.2)

extension Location_Nearby_Proto_Sharing_ButtonStatus: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension Location_Nearby_Proto_Sharing_EventType: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_EventCategory: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_NearbySharingStatus: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_Visibility: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_DataUsage: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_EstablishConnectionStatus: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_AttachmentTransmissionStatus: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_ConnectionLayerStatus: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_ProcessReceivedAttachmentsStatus: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_SessionStatus: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_ResponseToIntroduction: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_DeviceType: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_OSType: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_DeviceRelationship: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_LogSource: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_ServerActionName: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_ServerResponseState: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_SyncPurpose: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_ClientRole: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_ScanType: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_ParsingFailedType: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_AdvertisingMode: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_DiscoveryMode: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_ActivityName: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_ConsentType: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_ConsentAcceptanceStatus: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_ApkSource: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_InstallAPKStatus: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_VerifyAPKStatus: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_ShowNotificationStatus: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_PermissionRequestResult: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_PermissionRequestType: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_SharingUseCase: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_AppCrashReason: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_AttachmentSourceType: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_PreferencesAction: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_PreferencesActionStatus: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_FastInitState: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_FastInitType: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_DesktopNotification: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_DesktopTransferEventType: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_DecryptCertificateFailureStatus: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_ContactAccess: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_IdentityVerification: @unchecked Sendable {}
extension Location_Nearby_Proto_Sharing_ButtonStatus: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension Location_Nearby_Proto_Sharing_EventType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_EVENT_TYPE"),
    1: .same(proto: "ACCEPT_AGREEMENTS"),
    2: .same(proto: "ENABLE_NEARBY_SHARING"),
    3: .same(proto: "SET_VISIBILITY"),
    4: .same(proto: "DESCRIBE_ATTACHMENTS"),
    5: .same(proto: "SCAN_FOR_SHARE_TARGETS_START"),
    6: .same(proto: "SCAN_FOR_SHARE_TARGETS_END"),
    7: .same(proto: "ADVERTISE_DEVICE_PRESENCE_START"),
    8: .same(proto: "ADVERTISE_DEVICE_PRESENCE_END"),
    9: .same(proto: "SEND_FAST_INITIALIZATION"),
    10: .same(proto: "RECEIVE_FAST_INITIALIZATION"),
    11: .same(proto: "DISCOVER_SHARE_TARGET"),
    12: .same(proto: "SEND_INTRODUCTION"),
    13: .same(proto: "RECEIVE_INTRODUCTION"),
    14: .same(proto: "RESPOND_TO_INTRODUCTION"),
    15: .same(proto: "SEND_ATTACHMENTS_START"),
    16: .same(proto: "SEND_ATTACHMENTS_END"),
    17: .same(proto: "RECEIVE_ATTACHMENTS_START"),
    18: .same(proto: "RECEIVE_ATTACHMENTS_END"),
    19: .same(proto: "CANCEL_SENDING_ATTACHMENTS"),
    20: .same(proto: "CANCEL_RECEIVING_ATTACHMENTS"),
    21: .same(proto: "OPEN_RECEIVED_ATTACHMENTS"),
    22: .same(proto: "LAUNCH_SETUP_ACTIVITY"),
    23: .same(proto: "ADD_CONTACT"),
    24: .same(proto: "REMOVE_CONTACT"),
    25: .same(proto: "FAST_SHARE_SERVER_RESPONSE"),
    26: .same(proto: "SEND_START"),
    27: .same(proto: "ACCEPT_FAST_INITIALIZATION"),
    28: .same(proto: "SET_DATA_USAGE"),
    29: .same(proto: "DISMISS_FAST_INITIALIZATION"),
    30: .same(proto: "CANCEL_CONNECTION"),
    31: .same(proto: "LAUNCH_ACTIVITY"),
    32: .same(proto: "DISMISS_PRIVACY_NOTIFICATION"),
    33: .same(proto: "TAP_PRIVACY_NOTIFICATION"),
    34: .same(proto: "TAP_HELP"),
    35: .same(proto: "TAP_FEEDBACK"),
    36: .same(proto: "ADD_QUICK_SETTINGS_TILE"),
    37: .same(proto: "REMOVE_QUICK_SETTINGS_TILE"),
    38: .same(proto: "LAUNCH_PHONE_CONSENT"),
    39: .same(proto: "TAP_QUICK_SETTINGS_TILE"),
    40: .same(proto: "INSTALL_APK"),
    41: .same(proto: "VERIFY_APK"),
    42: .same(proto: "LAUNCH_CONSENT"),
    43: .same(proto: "PROCESS_RECEIVED_ATTACHMENTS_END"),
    44: .same(proto: "TOGGLE_SHOW_NOTIFICATION"),
    45: .same(proto: "SET_DEVICE_NAME"),
    46: .same(proto: "DECLINE_AGREEMENTS"),
    47: .same(proto: "REQUEST_SETTING_PERMISSIONS"),
    48: .same(proto: "ESTABLISH_CONNECTION"),
    49: .same(proto: "DEVICE_SETTINGS"),
    50: .same(proto: "AUTO_DISMISS_FAST_INITIALIZATION"),
    51: .same(proto: "APP_CRASH"),
    52: .same(proto: "TAP_QUICK_SETTINGS_FILE_SHARE"),
    53: .same(proto: "DISPLAY_PRIVACY_NOTIFICATION"),
    54: .same(proto: "DISPLAY_PHONE_CONSENT"),
    55: .same(proto: "PREFERENCES_USAGE"),
    56: .same(proto: "DEFAULT_OPT_IN"),
    57: .same(proto: "SETUP_WIZARD"),
    58: .same(proto: "TAP_QR_CODE"),
    59: .same(proto: "QR_CODE_LINK_SHOWN"),
    60: .same(proto: "PARSING_FAILED_ENDPOINT_ID"),
    61: .same(proto: "FAST_INIT_DISCOVER_DEVICE"),
    62: .same(proto: "SEND_DESKTOP_NOTIFICATION"),
    63: .same(proto: "SET_ACCOUNT"),
    64: .same(proto: "DECRYPT_CERTIFICATE_FAILURE"),
    65: .same(proto: "SHOW_ALLOW_PERMISSION_AUTO_ACCESS"),
    66: .same(proto: "SEND_DESKTOP_TRANSFER_EVENT"),
    67: .same(proto: "WAITING_FOR_ACCEPT"),
    68: .same(proto: "HIGH_QUALITY_MEDIUM_SETUP"),
    69: .same(proto: "RPC_CALL_STATUS"),
    70: .same(proto: "START_QR_CODE_SESSION"),
    71: .same(proto: "QR_CODE_OPENED_IN_WEB_CLIENT"),
    72: .same(proto: "HATS_JOINT_EVENT"),
    73: .same(proto: "RECEIVE_PREVIEWS"),
  ]
}

extension Location_Nearby_Proto_Sharing_EventCategory: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_EVENT_CATEGORY"),
    1: .same(proto: "SENDING_EVENT"),
    2: .same(proto: "RECEIVING_EVENT"),
    3: .same(proto: "SETTINGS_EVENT"),
    4: .same(proto: "RPC_EVENT"),
  ]
}

extension Location_Nearby_Proto_Sharing_NearbySharingStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_NEARBY_SHARING_STATUS"),
    1: .same(proto: "ON"),
    2: .same(proto: "OFF"),
  ]
}

extension Location_Nearby_Proto_Sharing_Visibility: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_VISIBILITY"),
    1: .same(proto: "CONTACTS_ONLY"),
    2: .same(proto: "EVERYONE"),
    3: .same(proto: "SELECTED_CONTACTS_ONLY"),
    4: .same(proto: "HIDDEN"),
    5: .same(proto: "SELF_SHARE"),
  ]
}

extension Location_Nearby_Proto_Sharing_DataUsage: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_DATA_USAGE"),
    1: .same(proto: "ONLINE"),
    2: .same(proto: "WIFI_ONLY"),
    3: .same(proto: "OFFLINE"),
  ]
}

extension Location_Nearby_Proto_Sharing_EstablishConnectionStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONNECTION_STATUS_UNKNOWN"),
    1: .same(proto: "CONNECTION_STATUS_SUCCESS"),
    2: .same(proto: "CONNECTION_STATUS_FAILURE"),
    3: .same(proto: "CONNECTION_STATUS_CANCELLATION"),
    4: .same(proto: "CONNECTION_STATUS_MEDIA_UNAVAILABLE_ATTACHMENT"),
    5: .same(proto: "CONNECTION_STATUS_FAILED_PAIRED_KEYHANDSHAKE"),
    6: .same(proto: "CONNECTION_STATUS_FAILED_WRITE_INTRODUCTION"),
    7: .same(proto: "CONNECTION_STATUS_FAILED_NULL_CONNECTION"),
    8: .same(proto: "CONNECTION_STATUS_FAILED_NO_TRANSFER_UPDATE_CALLBACK"),
    9: .same(proto: "CONNECTION_STATUS_LOST_CONNECTIVITY"),
    10: .same(proto: "CONNECTION_STATUS_INVALID_ADVERTISEMENT"),
  ]
}

extension Location_Nearby_Proto_Sharing_AttachmentTransmissionStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_ATTACHMENT_TRANSMISSION_STATUS"),
    1: .same(proto: "COMPLETE_ATTACHMENT_TRANSMISSION_STATUS"),
    2: .same(proto: "CANCELED_ATTACHMENT_TRANSMISSION_STATUS"),
    3: .same(proto: "FAILED_ATTACHMENT_TRANSMISSION_STATUS"),
    4: .same(proto: "REJECTED_ATTACHMENT"),
    5: .same(proto: "TIMED_OUT_ATTACHMENT"),
    6: .same(proto: "AWAITING_REMOTE_ACCEPTANCE_FAILED_ATTACHMENT"),
    7: .same(proto: "NOT_ENOUGH_SPACE_ATTACHMENT"),
    8: .same(proto: "FAILED_NO_TRANSFER_UPDATE_CALLBACK"),
    9: .same(proto: "MEDIA_UNAVAILABLE_ATTACHMENT"),
    10: .same(proto: "UNSUPPORTED_ATTACHMENT_TYPE_ATTACHMENT"),
    11: .same(proto: "NO_ATTACHMENT_FOUND"),
    12: .same(proto: "FAILED_NO_SHARE_TARGET_ENDPOINT"),
    13: .same(proto: "FAILED_PAIRED_KEYHANDSHAKE"),
    14: .same(proto: "FAILED_NULL_CONNECTION"),
    15: .same(proto: "FAILED_NO_PAYLOAD"),
    16: .same(proto: "FAILED_WRITE_INTRODUCTION"),
    17: .same(proto: "FAILED_UNKNOWN_REMOTE_RESPONSE"),
    18: .same(proto: "FAILED_NULL_CONNECTION_INIT_OUTGOING"),
    19: .same(proto: "FAILED_NULL_CONNECTION_DISCONNECTED"),
    20: .same(proto: "FAILED_NULL_CONNECTION_LOST_CONNECTIVITY"),
    21: .same(proto: "FAILED_NULL_CONNECTION_FAILURE"),
    22: .same(proto: "REJECTED_ATTACHMENT_TRANSMISSION_STATUS"),
    23: .same(proto: "TIMED_OUT_ATTACHMENT_TRANSMISSION_STATUS"),
    24: .same(proto: "NOT_ENOUGH_SPACE_ATTACHMENT_TRANSMISSION_STATUS"),
    25: .same(proto: "UNSUPPORTED_ATTACHMENT_TYPE_ATTACHMENT_TRANSMISSION_STATUS"),
    26: .same(proto: "FAILED_UNKNOWN_REMOTE_RESPONSE_TRANSMISSION_STATUS"),
    27: .same(proto: "NO_RESPONSE_FRAME_CONNECTION_CLOSED_LOST_CONNECTIVITY_TRANSMISSION_STATUS"),
    28: .same(proto: "NO_RESPONSE_FRAME_CONNECTION_CLOSED_TRANSMISSION_STATUS"),
    29: .same(proto: "LOST_CONNECTIVITY_TRANSMISSION_STATUS"),
    30: .same(proto: "FAILED_DISALLOWED_MEDIUM"),
  ]
}

extension Location_Nearby_Proto_Sharing_ConnectionLayerStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONNECTION_LAYER_STATUS_UNKNOWN"),
    1: .same(proto: "CONNECTION_LAYER_STATUS_SUCCESS"),
    2: .same(proto: "CONNECTION_LAYER_STATUS_ERROR"),
    3: .same(proto: "CONNECTION_LAYER_STATUS_OUT_OF_ORDER_API_CALL"),
    4: .same(proto: "CONNECTION_LAYER_STATUS_ALREADY_HAVE_ACTIVE_STRATEGY"),
    5: .same(proto: "CONNECTION_LAYER_STATUS_ALREADY_ADVERTISING"),
    6: .same(proto: "CONNECTION_LAYER_STATUS_ALREADY_DISCOVERING"),
    7: .same(proto: "CONNECTION_LAYER_STATUS_ALREADY_LISTENING"),
    8: .same(proto: "CONNECTION_LAYER_STATUS_END_POINT_IO_ERROR"),
    9: .same(proto: "CONNECTION_LAYER_STATUS_END_POINT_UNKNOWN"),
    10: .same(proto: "CONNECTION_LAYER_STATUS_CONNECTION_REJECTED"),
    11: .same(proto: "CONNECTION_LAYER_STATUS_ALREADY_CONNECTED_TO_END_POINT"),
    12: .same(proto: "CONNECTION_LAYER_STATUS_NOT_CONNECTED_TO_END_POINT"),
    13: .same(proto: "CONNECTION_LAYER_STATUS_BLUETOOTH_ERROR"),
    14: .same(proto: "CONNECTION_LAYER_STATUS_BLE_ERROR"),
    15: .same(proto: "CONNECTION_LAYER_STATUS_WIFI_LAN_ERROR"),
    16: .same(proto: "CONNECTION_LAYER_STATUS_PAYLOAD_UNKNOWN"),
    17: .same(proto: "CONNECTION_LAYER_STATUS_RESET"),
    18: .same(proto: "CONNECTION_LAYER_STATUS_TIMEOUT"),
  ]
}

extension Location_Nearby_Proto_Sharing_ProcessReceivedAttachmentsStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PROCESSING_STATUS_UNKNOWN"),
    1: .same(proto: "PROCESSING_STATUS_COMPLETE_PROCESSING_ATTACHMENTS"),
    2: .same(proto: "PROCESSING_STATUS_FAILED_MOVING_FILES"),
    3: .same(proto: "PROCESSING_STATUS_FAILED_RECEIVING_APK"),
    4: .same(proto: "PROCESSING_STATUS_FAILED_RECEIVING_TEXT"),
    5: .same(proto: "PROCESSING_STATUS_FAILED_RECEIVING_WIFI_CREDENTIALS"),
  ]
}

extension Location_Nearby_Proto_Sharing_SessionStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_SESSION_STATUS"),
    1: .same(proto: "SUCCEEDED_SESSION_STATUS"),
    2: .same(proto: "FAILED_SESSION_STATUS"),
  ]
}

extension Location_Nearby_Proto_Sharing_ResponseToIntroduction: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_RESPONSE_TO_INTRODUCTION"),
    1: .same(proto: "ACCEPT_INTRODUCTION"),
    2: .same(proto: "REJECT_INTRODUCTION"),
    3: .same(proto: "FAIL_INTRODUCTION"),
  ]
}

extension Location_Nearby_Proto_Sharing_DeviceType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_DEVICE_TYPE"),
    1: .same(proto: "PHONE"),
    2: .same(proto: "TABLET"),
    3: .same(proto: "LAPTOP"),
    4: .same(proto: "CAR"),
    5: .same(proto: "FOLDABLE"),
    6: .same(proto: "XR"),
  ]
}

extension Location_Nearby_Proto_Sharing_OSType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_OS_TYPE"),
    1: .same(proto: "ANDROID"),
    2: .same(proto: "CHROME_OS"),
    3: .same(proto: "IOS"),
    4: .same(proto: "WINDOWS"),
    5: .same(proto: "MACOS"),
  ]
}

extension Location_Nearby_Proto_Sharing_DeviceRelationship: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_DEVICE_RELATIONSHIP"),
    1: .same(proto: "IS_SELF"),
    2: .same(proto: "IS_CONTACT"),
    3: .same(proto: "IS_STRANGER"),
  ]
}

extension Location_Nearby_Proto_Sharing_LogSource: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED_SOURCE"),
    1: .same(proto: "LAB_DEVICES"),
    2: .same(proto: "INTERNAL_DEVICES"),
    3: .same(proto: "BETA_TESTER_DEVICES"),
    4: .same(proto: "OEM_DEVICES"),
    5: .same(proto: "DEBUG_DEVICES"),
    6: .same(proto: "NEARBY_MODULE_FOOD_DEVICES"),
    7: .same(proto: "BETO_DOGFOOD_DEVICES"),
    8: .same(proto: "NEARBY_DOGFOOD_DEVICES"),
    9: .same(proto: "NEARBY_TEAMFOOD_DEVICES"),
  ]
}

extension Location_Nearby_Proto_Sharing_ServerActionName: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_SERVER_ACTION"),
    1: .same(proto: "UPLOAD_CERTIFICATES"),
    2: .same(proto: "DOWNLOAD_CERTIFICATES"),
    3: .same(proto: "CHECK_REACHABILITY"),
    4: .same(proto: "UPLOAD_CONTACTS"),
    5: .same(proto: "UPDATE_DEVICE_NAME"),
    6: .same(proto: "UPLOAD_SENDER_CERTIFICATES"),
    7: .same(proto: "DOWNLOAD_SENDER_CERTIFICATES"),
    8: .same(proto: "UPLOAD_CONTACTS_AND_CERTIFICATES"),
    9: .same(proto: "LIST_REACHABLE_PHONE_NUMBERS"),
    10: .same(proto: "LIST_MY_DEVICES"),
    11: .same(proto: "LIST_CONTACT_PEOPLE"),
    12: .same(proto: "DOWNLOAD_CERTIFICATES_INFO"),
  ]
}

extension Location_Nearby_Proto_Sharing_ServerResponseState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_SERVER_RESPONSE_STATE"),
    1: .same(proto: "SERVER_RESPONSE_SUCCESS"),
    2: .same(proto: "SERVER_RESPONSE_UNKNOWN_FAILURE"),
    3: .same(proto: "SERVER_RESPONSE_STATUS_OTHER_FAILURE"),
    4: .same(proto: "SERVER_RESPONSE_STATUS_DEADLINE_EXCEEDED"),
    5: .same(proto: "SERVER_RESPONSE_STATUS_PERMISSION_DENIED"),
    6: .same(proto: "SERVER_RESPONSE_STATUS_UNAVAILABLE"),
    7: .same(proto: "SERVER_RESPONSE_STATUS_UNAUTHENTICATED"),
    8: .same(proto: "SERVER_RESPONSE_GOOGLE_AUTH_FAILURE"),
    9: .same(proto: "SERVER_RESPONSE_STATUS_INVALID_ARGUMENT"),
    10: .same(proto: "SERVER_RESPONSE_NOT_CONNECTED_TO_INTERNET"),
  ]
}

extension Location_Nearby_Proto_Sharing_SyncPurpose: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SYNC_PURPOSE_UNKNOWN"),
    1: .same(proto: "SYNC_PURPOSE_ON_DEMAND_SYNC"),
    2: .same(proto: "SYNC_PURPOSE_CHIME_NOTIFICATION"),
    3: .same(proto: "SYNC_PURPOSE_DAILY_SYNC"),
    4: .same(proto: "SYNC_PURPOSE_OPT_IN_FIRST_SYNC"),
    5: .same(proto: "SYNC_PURPOSE_CHECK_DEFAULT_OPT_IN"),
    6: .same(proto: "SYNC_PURPOSE_NEARBY_SHARE_ENABLED"),
    7: .same(proto: "SYNC_PURPOSE_SYNC_AT_FAST_INIT"),
    8: .same(proto: "SYNC_PURPOSE_SYNC_AT_DISCOVERY"),
    9: .same(proto: "SYNC_PURPOSE_SYNC_AT_LOAD_PRIVATE_CERTIFICATE"),
    10: .same(proto: "SYNC_PURPOSE_SYNC_AT_ADVERTISEMENT"),
    11: .same(proto: "SYNC_PURPOSE_CONTACT_LIST_CHANGE"),
    12: .same(proto: "SYNC_PURPOSE_SHOW_C11N_VIEW"),
    13: .same(proto: "SYNC_PURPOSE_REGULAR_CHECK_CONTACT_REACHABILITY"),
    14: .same(proto: "SYNC_PURPOSE_VISIBILITY_SELECTED_CONTACT_CHANGE"),
    15: .same(proto: "SYNC_PURPOSE_ACCOUNT_CHANGE"),
    16: .same(proto: "SYNC_PURPOSE_REGENERATE_CERTIFICATES"),
    17: .same(proto: "SYNC_PURPOSE_DEVICE_CONTACTS_CONSENT_CHANGE"),
  ]
}

extension Location_Nearby_Proto_Sharing_ClientRole: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CLIENT_ROLE_UNKNOWN"),
    1: .same(proto: "CLIENT_ROLE_SENDER"),
    2: .same(proto: "CLIENT_ROLE_RECEIVER"),
  ]
}

extension Location_Nearby_Proto_Sharing_ScanType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_SCAN_TYPE"),
    1: .same(proto: "FOREGROUND_SCAN"),
    2: .same(proto: "FOREGROUND_RETRY_SCAN"),
    3: .same(proto: "DIRECT_SHARE_SCAN"),
    4: .same(proto: "BACKGROUND_SCAN"),
  ]
}

extension Location_Nearby_Proto_Sharing_ParsingFailedType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FAILED_UNKNOWN_TYPE"),
    1: .same(proto: "FAILED_PARSE_ADVERTISEMENT"),
    2: .same(proto: "FAILED_CONVERT_SHARE_TARGET"),
  ]
}

extension Location_Nearby_Proto_Sharing_AdvertisingMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_ADVERTISING_MODE"),
    1: .same(proto: "SCREEN_OFF_ADVERTISING_MODE"),
    2: .same(proto: "BACKGROUND_ADVERTISING_MODE"),
    3: .same(proto: "MIDGROUND_ADVERTISING_MODE"),
    4: .same(proto: "FOREGROUND_ADVERTISING_MODE"),
    5: .same(proto: "SUSPENDED_ADVERTISING_MODE"),
  ]
}

extension Location_Nearby_Proto_Sharing_DiscoveryMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_DISCOVERY_MODE"),
    1: .same(proto: "SCREEN_OFF_DISCOVERY_MODE"),
    2: .same(proto: "BACKGROUND_DISCOVERY_MODE"),
    3: .same(proto: "MIDGROUND_DISCOVERY_MODE"),
    4: .same(proto: "FOREGROUND_DISCOVERY_MODE"),
    5: .same(proto: "SUSPENDED_DISCOVERY_MODE"),
  ]
}

extension Location_Nearby_Proto_Sharing_ActivityName: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_ACTIVITY"),
    1: .same(proto: "SHARE_SHEET_ACTIVITY"),
    2: .same(proto: "SETTINGS_ACTIVITY"),
    3: .same(proto: "RECEIVE_SURFACE_ACTIVITY"),
    4: .same(proto: "SETUP_ACTIVITY"),
    5: .same(proto: "DEVICE_VISIBILITY_ACTIVITY"),
    6: .same(proto: "CONSENTS_ACTIVITY"),
    7: .same(proto: "SET_DEVICE_NAME_DIALOG"),
    8: .same(proto: "SET_DATA_USAGE_DIALOG"),
    9: .same(proto: "QUICK_SETTINGS_ACTIVITY"),
    10: .same(proto: "REMOTE_COPY_SHARE_SHEET_ACTIVITY"),
    11: .same(proto: "SETUP_WIZARD_ACTIVITY"),
    12: .same(proto: "SETTINGS_REVIEW_ACTIVITY"),
  ]
}

extension Location_Nearby_Proto_Sharing_ConsentType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONSENT_TYPE_UNKNOWN"),
    1: .same(proto: "CONSENT_TYPE_C11N"),
    2: .same(proto: "CONSENT_TYPE_DEVICE_CONTACT"),
  ]
}

extension Location_Nearby_Proto_Sharing_ConsentAcceptanceStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONSENT_UNKNOWN_ACCEPT_STATUS"),
    1: .same(proto: "CONSENT_ACCEPTED"),
    2: .same(proto: "CONSENT_DECLINED"),
    3: .same(proto: "CONSENT_UNABLE_TO_ENABLE"),
  ]
}

extension Location_Nearby_Proto_Sharing_ApkSource: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_APK_SOURCE"),
    1: .same(proto: "APK_FROM_SD_CARD"),
    2: .same(proto: "INSTALLED_APP"),
  ]
}

extension Location_Nearby_Proto_Sharing_InstallAPKStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_INSTALL_APK_STATUS"),
    1: .same(proto: "FAIL_INSTALLATION"),
    2: .same(proto: "SUCCESS_INSTALLATION"),
  ]
}

extension Location_Nearby_Proto_Sharing_VerifyAPKStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_VERIFY_APK_STATUS"),
    1: .same(proto: "NOT_INSTALLABLE"),
    2: .same(proto: "INSTALLABLE"),
    3: .same(proto: "ALREADY_INSTALLED"),
  ]
}

extension Location_Nearby_Proto_Sharing_ShowNotificationStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_SHOW_NOTIFICATION_STATUS"),
    1: .same(proto: "SHOW"),
    2: .same(proto: "NOT_SHOW"),
  ]
}

extension Location_Nearby_Proto_Sharing_PermissionRequestResult: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PERMISSION_UNKNOWN_REQUEST_RESULT"),
    1: .same(proto: "PERMISSION_GRANTED"),
    2: .same(proto: "PERMISSION_REJECTED"),
    3: .same(proto: "PERMISSION_UNABLE_TO_GRANT"),
  ]
}

extension Location_Nearby_Proto_Sharing_PermissionRequestType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PERMISSION_UNKNOWN_TYPE"),
    1: .same(proto: "PERMISSION_AIRPLANE_MODE_OFF"),
    2: .same(proto: "PERMISSION_WIFI"),
    3: .same(proto: "PERMISSION_BLUETOOTH"),
    4: .same(proto: "PERMISSION_LOCATION"),
    5: .same(proto: "PERMISSION_WIFI_HOTSPOT"),
  ]
}

extension Location_Nearby_Proto_Sharing_SharingUseCase: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "USE_CASE_UNKNOWN"),
    1: .same(proto: "USE_CASE_NEARBY_SHARE"),
    2: .same(proto: "USE_CASE_REMOTE_COPY_PASTE"),
    3: .same(proto: "USE_CASE_WIFI_CREDENTIAL"),
    4: .same(proto: "USE_CASE_APP_SHARE"),
    5: .same(proto: "USE_CASE_QUICK_SETTING_FILE_SHARE"),
    6: .same(proto: "USE_CASE_SETUP_WIZARD"),
    7: .same(proto: "USE_CASE_NEARBY_SHARE_WITH_QR_CODE"),
    8: .same(proto: "USE_CASE_REDIRECTED_FROM_BLUETOOTH_SHARE"),
  ]
}

extension Location_Nearby_Proto_Sharing_AppCrashReason: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "APP_CRASH_REASON_UNKNOWN"),
  ]
}

extension Location_Nearby_Proto_Sharing_AttachmentSourceType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ATTACHMENT_SOURCE_UNKNOWN"),
    1: .same(proto: "ATTACHMENT_SOURCE_CONTEXT_MENU"),
    2: .same(proto: "ATTACHMENT_SOURCE_DRAG_AND_DROP"),
    3: .same(proto: "ATTACHMENT_SOURCE_SELECT_FILES_BUTTON"),
    4: .same(proto: "ATTACHMENT_SOURCE_PASTE"),
    5: .same(proto: "ATTACHMENT_SOURCE_SELECT_FOLDERS_BUTTON"),
    6: .same(proto: "ATTACHMENT_SOURCE_SHARE_ACTIVATION"),
  ]
}

extension Location_Nearby_Proto_Sharing_PreferencesAction: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PREFERENCES_ACTION_UNKNOWN"),
    1: .same(proto: "PREFERENCES_ACTION_NO_ACTION"),
    2: .same(proto: "PREFERENCES_ACTION_LOAD_PREFERENCES"),
    3: .same(proto: "PREFERENCES_ACTION_SAVE_PREFERENCESS"),
    4: .same(proto: "PREFERENCES_ACTION_ATTEMPT_LOAD"),
    5: .same(proto: "PREFERENCES_ACTION_RESTORE_FROM_BACKUP"),
    6: .same(proto: "PREFERENCES_ACTION_CREATE_PREFERENCES_PATH"),
    7: .same(proto: "PREFERENCES_ACTION_MAKE_PREFERENCES_BACKUP_FILE"),
    8: .same(proto: "PREFERENCES_ACTION_CHECK_IF_PREFERENCES_PATH_EXISTS"),
    9: .same(proto: "PREFERENCES_ACTION_CHECK_IF_PREFERENCES_INPUT_STREAM_STATUS"),
    10: .same(proto: "PREFERENCES_ACTION_CHECK_IF_PREFERENCES_FILE_IS_CORRUPTED"),
    11: .same(proto: "PREFERENCES_ACTION_CHECK_IF_PREFERENCES_BACKUP_FILE_EXISTS"),
  ]
}

extension Location_Nearby_Proto_Sharing_PreferencesActionStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PREFERENCES_ACTION_STATUS_UNKNOWN"),
    1: .same(proto: "PREFERENCES_ACTION_STATUS_SUCCESS"),
    2: .same(proto: "PREFERENCES_ACTION_STATUS_FAIL"),
  ]
}

extension Location_Nearby_Proto_Sharing_FastInitState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FAST_INIT_UNKNOWN_STATE"),
    1: .same(proto: "FAST_INIT_CLOSE_STATE"),
    2: .same(proto: "FAST_INIT_FAR_STATE"),
    3: .same(proto: "FAST_INIT_LOST_STATE"),
  ]
}

extension Location_Nearby_Proto_Sharing_FastInitType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FAST_INIT_UNKNOWN_TYPE"),
    1: .same(proto: "FAST_INIT_NOTIFY_TYPE"),
    2: .same(proto: "FAST_INIT_SILENT_TYPE"),
  ]
}

extension Location_Nearby_Proto_Sharing_DesktopNotification: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DESKTOP_NOTIFICATION_UNKNOWN"),
    1: .same(proto: "DESKTOP_NOTIFICATION_CONNECTING"),
    2: .same(proto: "DESKTOP_NOTIFICATION_PROGRESS"),
    3: .same(proto: "DESKTOP_NOTIFICATION_ACCEPT"),
    4: .same(proto: "DESKTOP_NOTIFICATION_RECEIVED"),
    5: .same(proto: "DESKTOP_NOTIFICATION_ERROR"),
  ]
}

extension Location_Nearby_Proto_Sharing_DesktopTransferEventType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DESKTOP_TRANSFER_EVENT_TYPE_UNKNOWN"),
    1: .same(proto: "DESKTOP_TRANSFER_EVENT_RECEIVE_TYPE_ACCEPT"),
    2: .same(proto: "DESKTOP_TRANSFER_EVENT_RECEIVE_TYPE_PROGRESS"),
    3: .same(proto: "DESKTOP_TRANSFER_EVENT_RECEIVE_TYPE_RECEIVED"),
    4: .same(proto: "DESKTOP_TRANSFER_EVENT_RECEIVE_TYPE_ERROR"),
    5: .same(proto: "DESKTOP_TRANSFER_EVENT_SEND_TYPE_START"),
    6: .same(proto: "DESKTOP_TRANSFER_EVENT_SEND_TYPE_SELECT_A_DEVICE"),
    7: .same(proto: "DESKTOP_TRANSFER_EVENT_SEND_TYPE_PROGRESS"),
    8: .same(proto: "DESKTOP_TRANSFER_EVENT_SEND_TYPE_SENT"),
    9: .same(proto: "DESKTOP_TRANSFER_EVENT_SEND_TYPE_ERROR"),
  ]
}

extension Location_Nearby_Proto_Sharing_DecryptCertificateFailureStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DECRYPT_CERT_UNKNOWN_FAILURE"),
    1: .same(proto: "DECRYPT_CERT_NO_SUCH_ALGORITHM_FAILURE"),
    2: .same(proto: "DECRYPT_CERT_NO_SUCH_PADDING_FAILURE"),
    3: .same(proto: "DECRYPT_CERT_INVALID_KEY_FAILURE"),
    4: .same(proto: "DECRYPT_CERT_INVALID_ALGORITHM_PARAMETER_FAILURE"),
    5: .same(proto: "DECRYPT_CERT_ILLEGAL_BLOCK_SIZE_FAILURE"),
    6: .same(proto: "DECRYPT_CERT_BAD_PADDING_FAILURE"),
  ]
}

extension Location_Nearby_Proto_Sharing_ContactAccess: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONTACT_ACCESS_UNKNOWN"),
    1: .same(proto: "CONTACT_ACCESS_NO_CONTACT_UPLOADED"),
    2: .same(proto: "CONTACT_ACCESS_ONLY_UPLOAD_GOOGLE_CONTACT"),
    3: .same(proto: "CONTACT_ACCESS_UPLOAD_CONTACT_FOR_DEVICE_CONTACT_CONSENT"),
    4: .same(proto: "CONTACT_ACCESS_UPLOAD_CONTACT_FOR_QUICK_SHARE_CONSENT"),
  ]
}

extension Location_Nearby_Proto_Sharing_IdentityVerification: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IDENTITY_VERIFICATION_UNKNOWN"),
    1: .same(proto: "IDENTITY_VERIFICATION_NO_PHONE_NUMBER_VERIFIED"),
    2: .same(proto: "IDENTITY_VERIFICATION_PHONE_NUMBER_VERIFIED_NOT_LINKED_TO_GAIA"),
    3: .same(proto: "IDENTITY_VERIFICATION_PHONE_NUMBER_VERIFIED_LINKED_TO_QS_GAIA"),
  ]
}

extension Location_Nearby_Proto_Sharing_ButtonStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BUTTON_STATUS_UNKNOWN"),
    1: .same(proto: "BUTTON_STATUS_CLICK_ACCEPT"),
    2: .same(proto: "BUTTON_STATUS_CLICK_REJECT"),
    3: .same(proto: "BUTTON_STATUS_IGNORE"),
  ]
}
